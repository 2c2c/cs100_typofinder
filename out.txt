# cs100 - software construction

This is a course on [how to be a hacker](http://www.catb.org/esr/faqs/hacker-howto.html).
Being a hacker [means a lot of things](http://www.catb.org/jargon/html/H/hacker.html).
It means:

1. wanting to know *how* and *why* computers work

2. being efficient / never repeating yourself

3. using and contributing to open source software

4. understanding the edge cases of your software

5. using tools in creative and unexpected ways

6. (occasionally) we combine all these together and break stuff

Hacking is a mindset.
I can't force it on you---it's up to you to embrace it.
For example, we'll be discussing many new tools in this course: a version control system called `git`, an editor called `vim`, debugging tools called `gdb`, `valgrind`, and `cppcheck`, and we'll be going into quite a bit more depth on how to use the `bash` shell and the `Linux` operating system.
All of these tools are very weird.
Using them will make you uncomfortable.
At first.
But these tools are powerful.
Mastering these tools will make you a *much* more efficient programmer.
Once you've mastered them, you'll never go back.

Your main goal in this course is to build your own unix shell.
This is the biggest project you've undertaken so far.
You'll be developing it as an open source project and will be forced to collaborate with each other at various points.

By the end of the course, you should be comfortable running your own open source project and contributing to other people's open source code.

### instructors

position | name | office hours
--- | --- | ---
lecturer | Mike Izbicki |  Thursday 3:30-5:00 PM, WCH110
teaching assistant | Taeyoung Kim | Tuesday 3:30-5:00 PM, WCH110

**IMPORTANT:**
If you want to contact the instructors about the course, you should NOT do it via email.
Instead, you should report an issue via github.
We will talk about how to do this in class.
This is a system similar to the piazza system you may already be familiar with, but it more popular for open source software development.

### text book

The course textbook is *The Art of Unix Programming* by Eric Steven Raymond (more commonly known as esr).
You can download it for free at [esr's website](http://www.catb.org/esr/writings/taoup/html).
All required reading is listed in the "assignments" category of the outline below.
It includes reading from the textbook and outside sources.
You can also get extra credit for reading [certain books I've selected](assignments/ec/ec-reading) about computer programming.

### course outline

week | date | assignments | topics
--- | --- | --- | ---
0 | Oct02 | | introduction; using vim
1 | Oct07 | Paul Graham on [what to do in college](http://www.paulgraham.com/college.html) and Ian Malpass's [advice to future software engineers](https://medium.com/@indec/advice-to-future-software-engineers-64a29669d179)| version control with git
1 | Oct09 | esr's [all about unix](http://www.catb.org/esr/writings/taoup/html/context.html) and [about common software licenses](http://www.catb.org/esr/writings/taoup/html/ch16s07.html) | version control with git
2 | Oct14 | quiz | syscalls: managing processes (`fork`,`wait`,`exec`,`perror`)
2 | Oct16 | esr's thoughts on [unix documentation](http://www.catb.org/esr/writings/taoup/html/ch18s02.html) and [part II](http://www.catb.org/esr/writings/taoup/html/ch18s06.html) | syscalls: managing files (`open`,`close`,`read`,`write`)
3 | Oct21 | hw0 | debugging tools (`gdb`)
3 | Oct23 | Paul Graham [on how to be a good hacker](http://www.paulgraham.com/gh.html) and Jeff Atwood on [how to become a better programmer](http://blog.codinghorror.com/how-to-become-a-better-programmer-by-not-programming/) | debugging tools (`valgrind`,`cppcheck`)
4 | Oct28 | quiz | syscalls: managing directories (`readdir`,`stat`)
4 | Oct30 | Ycombinator's [startup ideas we'd like to fund](http://old.ycombinator.com/ideas.html) and Paul Graham's [start up funding](http://paulgraham.com/startupfunding.html) | shell scripting: io redirection/piping
5 | Nov04 | hw1 | shell scripting: io redirection/piping
5 | Nov06 | Patrick McKenzie [on salary negotiation for programmers](http://www.kalzumeus.com/2012/01/23/salary-negotiation/) | syscalls: io redirection/piping (`pipe`,`dup`)
6 | Nov11 | quiz | shell scripting: control flow with `if` and `for`
6 | Nov13 | esr's thoughts on [using make](http://www.catb.org/esr/writings/taoup/html/ch15s04.html) | shell scripting: detailed makefiles
7 | Nov18 | hw2 | syscalls: signal handling (`signal`,`sigaction`)
7 | Nov20 | esr's classic [Master Foo](http://www.catb.org/esr/writings/taoup/html/unix_koans.html) | shell scripting: environment variables (`export`,`PATH`,`HOME`,`EDITOR`)
8 | Nov25 | quiz | syscalls: environment variables (`getenv`,`setenv`)
8 | Nov27 | | THANKSGIVING
9 | Dec02 | hw3 | syscalls: pthreads
9 | Dec04 | esr's thoughts on [flaws with unix](http://www.catb.org/esr/writings/taoup/html/ch20s03.html) | syscalls: sockets
10 | Dec11 | quiz | case study: hacking the email system and the [ioccc.org](http://ioccc.org)
10 | Dec13 | hw4 | case study: stuxnet and heartbleed

This schedule is only a rough outline, and will probably change a lot.
If there's something you want to learn not on the schedule, let me know!
We have a lot of flexibility in this course to learn fun things.

### grades

We will not be using ilearn in this course.
Instead everything will be done using a combination of git and bash scripts.
The file `GRADES.md` contains a detailed breakdown of how your grades will be stored electronically, and how you can access them.
We will be using this system as a case study in bash programming and the unix philosophy.

### cheating policy

Every assignment specifies different collaboration policies.
Some assignments will be individual, and some will be in a group.
Follow the specified policy exactly!

I take cheating seriously.
When I catch students cheating, I give them an F in the class.
Then I forward your case to the academic integrity board and recommend that you be expelled from UCR.
Finally, I will post a note on this project with your full name and a description of your infraction.
This will be available on the internet forever for future employers to find.

All of your code will be run through an automated cheating detector.
It is very good.
It understands C++ better than you do and can find instances of cheating much more sophisticated than just copy and pasting.

# grades

We will not be using ilearn in this course.
Instead, we will use git.
All of your grade information will be stored in the repo you forked during lab1.
This file contains detailed information about how your grades will be stored in that repo.

**IMPORTANT:**
If you did not give all of the instructors write access to your repository, then you won't be able to get your grades updated, and you will get zeros on the assignments!

**IMPORTANT:**
By default, github sets your repo to `public` and gives everyone read access.
That means everyone can view your grade.
If you do not want others to view your grade, you can set your repo to be `private` instead.
This won't affect our ability to grade your assignments.

## grade format

Every assignment has a corresponding directory.
In that directory is a file called `grade`.
This file contains your score on that assignment.

An example `grade` file might look like:

```
90 / 100

-5 points for making mistake X

-20 points for not doing task Y

+15 points extra credit for doing Z
```

The first line specifies how many points you earned on the assignment, and how many points the assignment is out of.
The rest of the file gives a detailed breakdown of why your assignment earned that final grade.

If the assignment has not yet been graded, then the contents of the file will contain just a slash and the number of points the assignment is worth:

```
/ 100
```

## checking your overall grade

You can use the `scripts/calcgrade.sh` file to calculate your whole grade for the course.
This script automatically downloads the latest version of your repo, inspects the grade you received on each assignment, and calculates your current and final grades for the course.

The `calcgrade.sh` script expects a single argument that corresponds to the github account of the grade you want to check.
For example, if you want to find the grade of the `examplestudent` account, you would run:

```
$ ./scripts/calcgrade.sh examplestudent
```

and the output looks something like:

```
finding grade for github account examplestudent
repository exists... fetching origin

===========================================
    grade        |  assignment
===========================================
    --- /   0    |  hw0-vim
     85 / 100    |  hw1-rshell
    --- / 100    |  hw2-ls
     33 / 100    |  hw3-piping
     54 / 100    |  hw4-signals
     10 /  10    |  lab0-vim
    --- /  10    |  lab1-git
      8 /  10    |  lab2-fork
    --- /  10    |  lab3-debugging1
    --- /  10    |  lab4-cp
    --- /  10    |  lab5-debugging2
    --- /  10    |  lab6-signal
    --- /  10    |  lab7-cstring
    --- /  10    |  lab8-spam
    --- /  10    |  lab9-rm
    --- /  50    |  linux
    --- /   0    |  reading
===========================================

running total =  190 /  320 = 58.64
overall total =  190 /  550 = 34.29
```

Notice that ungraded assignments are marked with a grade of `---` and not included in the running total.

## cheating

All of your grade information will be stored in your own git repository.
You have write access to this information, so you may be tempted to change it.
Don't!

We have access to the full changelog of all the files in your repo.
For example, if I run the command:

```
$ git log hw/hw1-rshell/grade
```

Then I will get output similar to:

```
commit b72f2c09206bb05c93612fea4cfc6c53f718988f
Author: Mike Izbicki <mike@izbicki.me>
Date:   Sat Jul 20 07:35:46 2014 -0700

    graded hw1

commit b72f2c09206bb05c93612fea4cfc6c53f718988f
Author: Mike Izbicki <mike@izbicki.me>
Date:   Sat Jul 12 11:52:42 2014 -0700

    initial commit
```

This tells us who has modified the file and what they've done.
If you modify your grades, we will catch you.
As a reminder, I take cheating very seriously.
I will forward your case to the academic conduct committee and recommend you be expelled from UCR.

If you are an advanced git user, you may be aware that it's possible to commit changes under other people's names using the `--author` flag.
All of our grading scripts, however, sign the commits we make using the RSA public key crypto system.
Since you do not have access to the instructors' private keys, you will not be able to properly sign the grading commits.

**IMPORTANT:**
I encourage you to try to "hack" this grading system.
And if you find a way to change your grades in any way, I will give you a considerable amount of extra credit in this course.
But please do it responsibly and let the instructors know what you're doing before you try.

Valgrind Tutorial
=================

What is Valgrind?
-----------------

Valgrind is a linux tool that helps you deal with debugging memory management issues. 

Valgrind has a function called Memcheck that will display the number of allocations and deallocations in bytes.

Checking for problems
---------------------


let's start with a code example from the program example1.cpp:

```
    int main()
    {   
        char *var = new char[1024};
        return 0;
    }
```

In the code above, we can see that we have allocated some memory using the ```new``` operator.

You can run this program in Valgrind using the commands:

```
    $ g++ example1.cpp
    $ valgrind --tool=memcheck ./a.out
```
   
    
We get the following output:

```
    ==4090== Memcheck, a memory error detector
    ==4090== Copyright (C) 2002-2013, and GNU GPL'd, by Julian Seward et al.
    ==4090== Using Valgrind-3.10.0.SVN and LibVEX; rerun with -h for copyright info
    ==4090== Command: ./a.out
    ==4090== 
    ==4090==    
    ==4090== HEAP SUMMARY:  
    ==4090==     in use at exit: 1,024 bytes in 1 blocks
    ==4090==   total heap usage: 1 allocs, 0 frees, 1,024 bytes allocated
    ==4090== 
    ==4090== LEAK SUMMARY:
    ==4090==    definitely lost: 1,024 bytes in 1 blocks
    ==4090==    indirectly lost: 0 bytes in 0 blocks
    ==4090==      possibly lost: 0 bytes in 0 blocks
    ==4090==    still reachable: 0 bytes in 0 blocks
    ==4090==         suppressed: 0 bytes in 0 blocks
    ==4090== Rerun with --leak-check=full to see details of leaked memory
    ==4090== 
    ==4090== For counts of detected and suppressed errors, rerun with: -v
    ==4090== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
```


If we look at the line under ```HEAP SUMMARY```, we can see that there were still 1,024 bytes still in use when the program exited. These 1024 bytes come from when we allocated the memory for our ```char *```.

Also at the next line, we can see that there was 1 allocation and 0 deallocation. This 1 allocation comes from calling the ```new``` function and the 0 deallocations comes from not calling the ```delete``` function. This implies that there is a memory leak in our program.

We can also look at the ```LEAK SUMMARY``` to see if we can recover any leaked memory.

Looking at the line right below, we see that the 1,024 bytes lost are not recoverable.


### How to fix memory leaks


To obtain more information about where the memory leak may have occured you can type the command:

```
    $ valgrind --tool=memcheck --leak-check=full ./a.out
```


The extra flag in this call will print out information about what function could be causing the leak and which function call is creating the possiblity of the leak.

Between the ```HEAP SUMMARY``` and ```LEAK SUMMARY``` we will get the message:


```
    ==4102== 1,024 bytes in 1 blocks are definitely lost in loss record 1 of 1
    ==4102==    at 0x4C2B800: operator new[](unsigned long) (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)
    ==4102==    by 0x40071E: main (in /home/william/cs100/hw5/a.out)
```

We can see that in the third line, Valgrind says that the memory leak is cause BY the function main and in the second line, Valgrind says the leak is cause AT ```new[]```.
We can also see that all the memory that was not deallocated was definitely lost, meaning we can not retrieve this memory.

This information will help you find where your leaks are at in your program.

     
### Fix all leaks and rerun


If we take our old program example1.cpp, and add a ```delete``` right under the ```new``` statement, our problem should be fixed!

This is an important problem to fix because if you never free up your memory when you run programs, it could cause you to run out of memory for your computer. This is not a very good situation to be in.


```
    int main()
    {   
        char *var = new char[1024};
        delete [] var;
        return 0;
    }
```


Now if we recompile and run Valgrind with Memcheck we get:

```
    $ g++ example1.cpp
    $ valgrind --tool=memcheck ./a.out
```


```
    ==2284== Memcheck, a memory error detector
    ==2284== Copyright (C) 2002-2013, and GNU GPL'd, by Julian Seward et al.
    ==2284== Using Valgrind-3.10.0.SVN and LibVEX; rerun with -h for copyright info
    ==2284== Command: ./a.out
    ==2284== 
    ==2284== 
    ==2284== HEAP SUMMARY:
    ==2284==     in use at exit: 0 bytes in 0 blocks
    ==2284==   total heap usage: 1 allocs, 1 frees, 1,024 bytes allocated
    ==2284== 
    ==2284== All heap blocks were freed -- no leaks are possible
    ==2284== 
    ==2284== For counts of detected and suppressed errors, rerun with: -v
    ==2284== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
```

If we look at the ```HEAP SUMMARY``` section, we can see that our change worked and that for 1 allocation we have 1 free.

We just looked at a very simple example that only has 6 lines of code, of course there will be more complicated programs and now I will demonstrate Valgrind and Memcheck with more complex program, example2.cpp.

Using Valgrind on a more difficult example
------------------------------------------


```
    #include <iostream>
    #include <cstring>
     
    using namespace std;
     
    void doSomething(char *ptr)
    {
        char *var2 = new char[1024]; // create a new char*
        strcpy(var2,ptr); // copy old char* into new char*
        cout << var2 << endl; // output new char*
        //delete [] var2;
    }
     
    int main()
    {   
        char *var = new char[1024]; //create char*
        string str = "hello world"; //create string to go into char*
        strcpy(var,str.c_str()); //copy string into char*
        cout << var << endl; // output char*
        doSomething(var); // call function with char*
        //delete [] var;
        return 0; 
    }  
```

This program listed above just creates a character string or cstring and copies the string "hello world" into it. Then the program outputs the cstring. Then it passes this cstring into a function which declares another cstring and copies the first cstring into the second one. Then the function prints out the cstring. The following is what is supposed to be output by this program

```
    hello world
    hello world
```

In our program above, we call the ```new``` operator twice and never call the ```delete``` operator. We call the first ```new``` operator in our ```main``` function and the second ```new``` in our function ```doSomething```. 

Now lets run our program with Valgrind and Memcheck:

```
    $ g++ example2.cpp
    $ valgrind --tool=memcheck ./a.out
```
We will get the following message:

```
    memory error detector
    ==3311== Copyright (C) 2002-2013, and GNU GPL'd, by Julian Seward et al.
    ==3311== Using Valgrind-3.10.0.SVN and LibVEX; rerun with -h for copyright info
    ==3311== Command: ./a.out
    ==3311== 
    hello world
    hello world
    ==3311== 
    ==3311== HEAP SUMMARY:
    ==3311==     in use at exit: 2,048 bytes in 2 blocks
    ==3311==   total heap usage: 3 allocs, 1 frees, 2,084 bytes allocated
    ==3311== 
    ==3311== LEAK SUMMARY:
    ==3311==    definitely lost: 2,048 bytes in 2 blocks
    ==3311==    indirectly lost: 0 bytes in 0 blocks
    ==3311==      possibly lost: 0 bytes in 0 blocks
    ==3311==    still reachable: 0 bytes in 0 blocks
    ==3311==         suppressed: 0 bytes in 0 blocks
    ==3311== Rerun with --leak-check=full to see details of leaked memory
    ==3311== 
    ==3311== For counts of detected and suppressed errors, rerun with: -v
    ==3311== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0))')
```


As we can see the program runs normal, printing out "hello world" twice under the ```Command: ./a.out``` line, but when we look at the ```HEAP SUMMARY``` we see that there were 3 allocations and 1 free. This means that we have a memory leak again.
 
If we look back at our program we can see that we used ```new``` but never called ```delete```.

As stated above ```Delete``` is neccesary to free up memory so that you do run into memory issues later on.
 
To fix our problem we need to add in some deletes for the ```VAR``` pointer and the ```PTR``` pointer like such:

```
    #include <iostream>
    #include <cstring>
 
    using namespace std;

    void doSomething(char *ptr)
    {
        char *var2 = new char[1024]; // create a new char*
        strcpy(var2,ptr); // copy old char* into new char*
        cout << var2 << endl; // output new char*
        delete [] var2;
    }
    
    int main()
    {   
        char *var = new char[1024]; //create char*
        string str = "hello world"; //create string to go into char*
        strcpy(var,str.c_str()); //copy string into char*
        cout << var << endl; // output char*
        doSomething(var); // call function with char*
        delete [] var;
        return 0; 
    } 
```


And now when we put this through Valgrind, we should not have any memory leaks.

```
    $ g++ example2.cpp
    $ valgrind --tool=memcheck ./a.out
```

```
    ==3413== HEAP SUMMARY:
    ==3413==     in use at exit: 0 bytes in 0 blocks
    ==3413==   total heap usage: 3 allocs, 3 frees, 2,084 bytes allocated
    ==3413==
    ==3413== All heap blocks were freed -- no leaks are possible
    ==3413== 
    ==3413== For counts of detected and suppressed errors, rerun with: -v
    ==3413== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0))')
```

Now that we made those changes, we can see that there were 3 allocations and 3 frees, which fixes our memory leak problem.

One last example
----------------

While Valgrind can check if you have deallocated memory, it can also check if you have allocated it in the first place.

If we take our example2.cpp code and modify it slightly on the first line in ```main```:

```
    #include <iostream>
    #include <cstring>
 
    using namespace std;

    void doSomething(char *ptr)
    {
        char *var2 = new char[1024]; // create a new char*
        strcpy(var2,ptr); // copy old char* into new char*
        cout << var2 << endl; // output new char*
        delete [] var2;
    }
    
    int main()
    {   
        char *var;       //= new char[1024]; //create char*
        string str = "hello world"; //create string to go into char*
        strcpy(var,str.c_str()); //copy string into char*
        cout << var << endl; // output char*
        doSomething(var); // call function with char*
        delete [] var;
        return 0; 
    } 
```
I modified the ```char *var = new char[1024]``` to ```char *var``` in order to induce the problem of not allocating memory before using that memory.

When we compile and run this program through Valgrind using Memcheck, we get:

```
    $ g++ example2.cpp
    $ valgrind --tool=memcheck ./a.out
```

```
    ==4942== Memcheck, a memory error detector
    ==4942== Copyright (C) 2002-2013, and GNU GPL'd, by Julian Seward et al.
    ==4942== Using Valgrind-3.10.0.SVN and LibVEX; rerun with -h for copyright info
    ==4942== Command: ./a.out
    ==4942== 
    ==4942== Use of uninitialised value of size 8
    ==4942==    at 0x4C2E1E0: strcpy (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)
    ==4942==    by 0x400C4D: main (in /home/william/ucr-cs100/tutorials/valgrind/a.out)
    ==4942== 
    ==4942== 
    ==4942== Process terminating with default action of signal 11 (SIGSEGV)
    ==4942==  Bad permissions for mapped region at address 0x400AC0
    ==4942==    at 0x4C2E1E0: strcpy (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)
    ==4942==    by 0x400C4D: main (in /home/william/ucr-cs100/tutorials/valgrind/a.out)
    ==4942== 
    ==4942== HEAP SUMMARY:
    ==4942==     in use at exit: 36 bytes in 1 blocks
    ==4942==   total heap usage: 1 allocs, 0 frees, 36 bytes allocated
    ==4942== 
    ==4942== LEAK SUMMARY:
    ==4942==    definitely lost: 0 bytes in 0 blocks
    ==4942==    indirectly lost: 0 bytes in 0 blocks
    ==4942==      possibly lost: 36 bytes in 1 blocks
    ==4942==    still reachable: 0 bytes in 0 blocks
    ==4942==         suppressed: 0 bytes in 0 blocks
    ==4942== Rerun with --leak-check=full to see details of leaked memory
    ==4942== 
    ==4942== For counts of detected and suppressed errors, rerun with: -v
    ==4942== Use --track-origins=yes to see where uninitialised values come from
    ==4942== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 0 from 0)
    Segmentation fault (core dumped)
```

We can see right under ```Command:``` that we have the statement ```Use of uninitialised value of size 8```, this statement implies that we tried to use memory that we have not allocated which would cause a segmentation fault. This segmentation fault is shown at the end of the output.

We also see that below the line ```Process terminating with default action of signal 11(SIGSEGV)``` we get the message ```Bad permissions for mapped region at address 0x400AC0```. The ```Bad permission``` statement also states that we have not allocated the memory that we want to access.

We can see that Valgrind and Memcheck are trying to help us find our issue by giving us the message ```Use --track-origins=yes to see where uninitialised values come from```. So lets give this a try ourselves:

Let's run the command:

```
    $ valgrind --tool=memcheck --track-origins=yes ./a.out
```

We get the following output that is different from before:

```
    ==5278== Use of uninitialised value of size 8
    ==5278==    at 0x4C2E1E0: strcpy (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)
    ==5278==    by 0x400C4D: main (in /home/william/ucr-cs100/tutorials/valgrind/a.out)
    ==5278==  Uninitialised value was created by a stack allocation
    ==5278==    at 0x400BFA: main (in /home/william/ucr-cs100/tutorials/valgrind/a.out)
```

The extra two lines added from before tell you what function the uninitialised value was created in, in this case ```main```.


This feature of Valgrind and Memcheck can help tremendously in debugging your programs and save you tons of time.

Conclusion
----------

Valgrind has a lot of functionality that can drastically decrease your debugging time and let you focus on being a better programmer. 

Now you can test your programs uing Valgrind to catch the pesky memory leaks that are almost impossible to find with the naked eye.

Happy programming!!!
#Syscalls and How to Use Them

Here, we will present a list of functions that will be useful when programming your own shell.  These functions are called system calls, and they differ from regular functions because a syscall requests a specific service from the operating system’s kernel. 

What’s really cool about syscalls are its error checking capabilities. Each syscall has access to a universal variable `errno`, `include <errno.h>` is required to use this variable, that it set to indicate what error has occured. The return value of each syscall can be furthered combined with other functions to make error checking much easier, which can save many headaches in the long run.

Syscalls might seem confusing to use but we’ll try our best to explain some of them in this list! If you want any more information we've included a link to the man page for each syscall.


##fork:

**includes:**  `#include <unistd.h>`

**declaration:** `pid_t fork(void);`

**returns:** `fork` returns the pid of the child process that it creates, if an error occurs -1 is returned.

[man page](http://linux.die.net/man/2/fork)

This is perhaps one of the most important syscall of them all (one syscall to rule them all!) so make sure you really understand this one.

`fork` creates a new process so you can have two things happening at once (multitasking, huzzah!). To create this new process, `fork` creates a copy of the process that was already running. This new process is called a child process, while the older process is called the parent process. 

If you’re creating your own bash shell you will HAVE to use `fork`. You'll use the child process of the `fork` to execute all of your commands. Inside of the child process is where you’ll functions such as `exec`, which require two processes (more on this later).

`fork` is without a doubt one of the more complicated syscalls and is harder to understand; therefore, we highly encourage you read up on it from multiple sources, and really gain a good understanding of it.

Here is an example of `fork`:
```
int pid = fork();
if(pid == 0)//when pid is 0 you are in the child process
{
   cout<<"This is the child process "; 
   exit(1);  //when the child process finishes doing what we want it to, cout, we want to kill the child process so it doesn’t go on in the program so we exit
}
//if pid is not 0 then we’re in the parent
else if(pid > 0) //parent function
{
   if( -1 == wait(0)) //wait for the child process to finish executing, wait will be explained later on
   perror(“There was an error with wait().”);
}

```

Here we’re setting `pid`, which is an `int`, which also works even though the declaration returns `pid_t`, to the pid of the child process when we’re in the parent, else we return 0 in the child. Everything that happens inside the if statement is everything the child process executes. This happens because `fork` returns 0 when it is the child process, and that’s how we know when to go in the if statement. You have to have the `exit()` statement when you’re done executing everything you want to in the child. If the exit statement isn't present, the child will become a zombie process - that is, it will never never exit, and continue to run in the background, taking up memory and hampering the program's performance - and we don't want that do we? 

Of course, with a child function, there has to be a parent function. In this particular function, the parent function simply waits for the child process to finish running (because of the wait call, which will be explained later), and executes after the child procses is finished.

##perror:

**includes:** `#include <stdio.h>, #include <errno.h>`

**declaration:** `void perror(const char *s);`

**returns:** No return value.

[man page](http://linux.die.net/man/3/perror)

The glorious error checker! `perror` is used when an error occurs in a syscall, and techincally isn't a syscall - rather its used WITH every single syscall. The parameter of of `perror` which is a `const char *s` is whatever c-string you wish to output when an error happens (examples below). `perror` outputs your custom c-string and then outputs information on the specific error that happened using information from `errno`. 
    `perror` becomes very useful when you’re debugging your program. If an error happenes you’ll be able to ouput your own custom message, which can make the error much easier to find. `perror` is extremely crucial while coding, and adding them after each syscall is considered proper coding etiquette - in fact, many instructors and professors may dock points for not having them (I was a "victim" of this my first assignment). 

Now, we’ll add `perror` to the last example:
```
int pid = fork();
if(pid == -1)//fork’s return value for an error is -1
{
   perror("There was an error with fork(). ");
   exit(1);//there was an error with fork so exit the program and go back and fix it
}
else if(pid == 0)//when pid is 0 you are in the child process
{
   cout<<"This is the child process "; 
   exit(1);  //when the child process finishes doing what we want it to, cout, we want to kill the child process so it doesn’t go on in the program so we exit
}
//if pid is not 0 then we’re in the parent
```
This example adds `perror` to the example we started in `fork`. The if statement basically says if there’s an error in the syscall, then output an error message and exit the program. As you can see, the parameter for `perror` is a c-string, in this case it’s, `There was an error with fork().` This message can be customized however you desire. You can output info about the function its in, the line its on - the choice is yours! But beware, with great power comes great responsibility! Outputting error messages that are irrelevant to your function/program are unlikely to be very helpful.

##wait:

**includes:** `#include <sys/types.h>`
          `#include <sys/wait.h>`

**declaration:** `pid_t wait(int *status);`
        usually when using `wait`, it is used as such: `wait(0);`

**returns:** When an error occurs -1 is returned otherwise it returns the pid of the child that was killed.

[man page](http://linux.die.net/man/2/wait)

`wait` is a system call that is used to wait for state changes in a child function of the parent process. It also obtains information about the child function when its state changes. 

`wait` is commonly used along with the `fork` function (and is pretty much a necessity). `wait` is usually used in the parent function, and tells the parent process to wait for the child process to finish executing before moving on. It also prevents two processes from running at once. However, if you want a process to run in the background in your shell (aka you want two processes running at the same time), you wouldn't want to use `wait`.

examples: here is an example of `wait` with `fork`.
```
int pid = fork();
if(pid == -1)//fork’s return value for an error is -1
{
   perror("There was an error with fork(). ");
   exit(1);//there was an error with fork so exit the program and go back and fix it
}
else if(pid == 0)//when pid is 0 you are in the child process
{
   cout<<"This is the child process "; 
   exit(1);  //when the child process finishes doing what we want it to, cout, we want to kill the child process so it doesn’t go on in the program so we exit
}
//if pid is not 0 then we’re in the parent
else if(pid > 0) //parent function
{
   if( -1 == wait(0)) //wait for the child process to finish executing
   perror(“There was an error with wait().”);
}
```

##exec:

**includes:** `#include <unistd.h>`

**declaration:** (multiple declarations depending on which `exec` funtion is used)

Here is an example of the two most common ones: `int execv(const char *path, char *const argv[]);`  `int execvp(const char *file, char *const argv[]);`

**returns:** `exec` only returns if there was an error, and in that particular case, it returns a -1.

[man page](http://linux.die.net/man/3/exec)

`exec` can be used to perform commands in the bash shell, such as `ls` `cat` and `echo`, they usually take in some form of converted user input. The two most commonly used ones are `execv` and `execvp`, but we encourage you to look up the other forms of `exec`! 

Now you may be wondering what the difference between the two of them is. `execv` requires that you append the path for the command to it, while `execvp` will automatically retrieve the path for you. Unless you are specifically required to use `execv` (e.g. your instructor wants you to use the path variable to find the particular command the user input), PLEASE use `execvp`. It will save you so much time, and will give you many more hours of much needed sleep.

We’ll show you an example of `execvp` that was used in the child function, in a program meant to create a bash shell:

```
int pid = fork();
if(pid == -1)//fork’s return value for an error is -1
{
   perror("There was an error with fork(). ");
   exit(1);//there was an error with fork so exit the program and go back and fix it
}
else if(pid == 0)//when pid is 0 you are in the child process
{
   cout<<"This is the child process ";
   if(-1 == execvp(argv[0], argv)) 
      perror("There was an error in execvp. ");


   exit(1);  //when the child process finishes doing what we want it to, cout, we want to kill the child process so it doesn’t go on in the program so we exit
}
//if pid is not 0 then we’re in the parent
else if(pid > 0) //parent function
{
   if( -1 == wait(0)) //wait for the child process to finish executing
   perror(“There was an error with wait().);
}
```

(Again, we’re using `perror` to check for errors. PLEASE remember to do so as well!)

The parameters for `execvp` are: `const char *file, char *const argv[]`. In this example, `file` is `argv[0]` and `argv` is `argv[]`. `argv`, in this example, is a char pointer pointer containing the user input of what commands they wish to execute. 

For example, the user can input `ls -l -a` and `argv[0] = ls`, `argv[1]= -l`, `argv[2]= -a`. So esentially, `argv[0]` is the command, while everything after is the flag.

As we told you above, `execvp` finds the path for you. If you wanted to use `execv` you would have to add the path to the front of the command, for example if you input `ls` the program would change it to `/usr/bin/ls` for the `execv` call.


##dup:

**includes:** `#include <unistd.h>`

**declaration:** These are the two `dup` declarations that are most useful: 
                 `int dup(int oldfd);`  `int dup2(int oldfd, int newfd);`

**returns:** When an error occurs `dup` returns -1 otherwise `dup` returns the new file descriptor.

[man page](http://linux.die.net/man/2/dup)

We all know about the default file descriptors 0, 1 and 2 with 0 meaning stdin, 1 meaning stdout and 2 meaing stderr. `dup(int oldfd)` can be used to copy the file descriptor given for `oldfd`, for example we can do `int fd = dup(1)` which copies stdout to `fd`. `dup` chooses our new file descriptor by choosing the lowest number of the unused descriptors, so if we only have 0, 1 and 2 as our file descriptors(only the default ones) it will choose 3 as our new one. So, in this `dup` example our new `fd` can be used interchangeably with stdout. 

Now say, for example, we wanted to redirect the stdout to the screen into a file. We could use `dup2` (we could also use `dup` but I think `dup2` is a simpler way). The way `dup2` works is it takes two parameters `int oldfd` and `int newfd`, `oldfd` is the file descriptor you want to change to what the `newfd`. Let's take our redirect example, we want to take stdout which is 1 and instead of linking it to 1 we want to link it to whatever file descriptor belongs to the file we want to redirect to. For this redirection we would do something like: `dup2(fd,1)` (where `fd` is the file descriptor for the file we want to write to). `dup2` also closes `newfd` after the call. Therefore, after this call stdout is now closed and instead it is rerouted to the file.


In our previous example we've added a small snippet of `dup` at the end.
```
int pid = fork();
if(pid == -1)//fork’s return value for an error is -1
{
   perror("There was an error with fork(). ");
   exit(1);//there was an error with fork so exit the program and go back and fix it
}
else if(pid == 0)//when pid is 0 you are in the child process
{
   cout<<"This is the child process ";
   if(-1 == execvp(argv[0], argv)) 
      perror("There was an error in execvp. ");

   exit(1);  //when the child process finishes doing what we want it to, cout, we want to kill the child process so it doesn’t go on in the program so we exit
}
//if pid is not 0 then we’re in the parent
else if(pid > 0) //parent function
{
   if( -1 == wait(0)) //wait for the child process to finish executing
      perror(“There was an error with wait().);

}
int savestdin;
if(-1 == (savestdin = dup(0)))//savestdin is now the same as regular stdin
   perror("There is an error with dup. ");
   
   //something can be done here to overwrite stdin, for example redirection
   
if(-1 == dup2(savestdin,0))//restore stdin, if we would have overwritten stdin this is how we would restore it
   perror("There is an error with dup2. ");
```

Here we can see both `dup` and `dup2` being used. 


##pipe:

**includes:** `#include <unistd.h>`
          `#include <fcntl.h>`

**declaration:** There are two different declarations for `pipe`:
               `int pipe(int pipefd[2]);`
               `int pipe2(int pipefd[2], int flags);`

**returns:** When an error occurs -1 is returned, otherwise 0 is returned.

[man page](http://linux.die.net/man/2/pipe)

`pipe` is another syscall that is harder to understand, so PLEASE utilize outside resources if need be!
   
`pipe` essentially creates an imaginary file that you can write to and read from. The parameter is an int array with two elements, which are the file descriptors for the imaginary file. In the example bewlow, `fd[0]` is the read end of the pipe and `fd[1]` is the write end of the pipe. Let me be clear, however, that pipe ignores the input and only uses the write end as output to whatever it is piping to. 

This function is essential when implementing piping in a bash shell. Piping is moving the stdout of the left side of the pipe into the stdin of whatever program is on the right side of the pipe. For example, you have an executable `names` which outputs a list of names in a random order you can pipe this into `sort` which will sort it alphabetically. This command would look like: `names | sort`. The end result would be the contents of the name executable output to the screen, except sorted. 
   
Now that we’ve gone over the basics of what piping is we can talk about how to use the syscall `pipe` to create this. Because `pipe` creates an imaginary file that you can read and write from you can use this to implement piping in whatever program you desire to do so in. You will take the stdout of the command on the left side of the pipe symbol and write it to the pipe with `dup`. Then, later, you will read that data from the read end of the pipe.
 
Here’s an example of `pipe` in action:
```
int fd[2];
if(pipe(fd) == -1)//call to pipe, it puts the read end and write end file descriptors in fd
   perror("There was an error with pipe(). ");

int pid = fork();
if(pid == -1)//fork’s return value for an error is -1
{
   perror("There was an error with fork(). ");
   exit(1);//there was an error with fork so exit the program and go back and fix it
}
else if(pid == 0)//when pid is 0 you are in the child process
{
   cout<<"This is the child process ";

   //write to the pipe
   if(-1 == dup2(fd[1],1))//make stdout the write end of the pipe 
      perror("There was an error with dup2. ");
   if(-1 == close(fd[0])//close the read end of the pipe because we're not doing anything with it right now
      perror("There was an error with close. ");

   if(-1 == execvp(argv[0], argv)) 
      perror("There was an error in execvp. ");


   exit(1);  //when the child process finishes doing what we want it to, cout, we want to kill the child process so it doesn’t go on in the program so we exit
}
//if pid is not 0 then we’re in the parent
else if(pid > 0) //parent function
{
   //read end of the pipe
   int savestdin;
   if(-1 == (savestdin = dup(0)))//need to restore later or infinite loop
      perror("There is an error with dup. ");
   if(-1 == dup2(fd[0],0))//make stdin the read end of the pipe 
      perror("There was an error with dup2. ");
    if(-1 == close(fd[1])//close the write end of the pipe because we're not doing anything with it right now
      perror("There was an error with close. ");
   if( -1 == wait(0)) //wait for the child process to finish executing
      perror(“There was an error with wait().);

   //here you have to do another fork to execute the right side of the pipe command, as in the above example (“names | sort”) you would execute the sort command, we will leave this as an example for you to do.

}
if(-1 == dup2(savestdin,0))//restore stdin
   perror("There is an error with dup2. ");
```

Here we see the full use of the `pipe` syscall. When we call `pipe` we have our `int fd[2]` as the parameter, `pipe` populates this array with the file descriptors of the read and write end of the imaginary file that is created. Then we `fork` the process, and in the child we change the stdout of whatever you are running to the write end of the imaginary file. In our example of `names|sort` the output of our names executable will be the input of our file. Then we go to our parent function and set the stdin to the read end of the `pipe`. We do this because we want the thing we wrote to the imaginary file to be the input to the right side of the pipe. In our example `names|sort` we want the names output to be the input of the sort program. After this we have to immediately call another `fork` function to execute the right side of the pipe. For this we have to call a function that is similar to the `exec` example, we will leave this as a workable example for you.

##getcwd:

**includes:** `#include <unistd.h>`

**declaraton:** `char *getcwd(char *buf, size_t size);`

**returns:** When successful, the function returns a pointer to a `string` containing the pathname of the current working directory. On error, it returns `NULL`.

[man page](http://linux.die.net/man/3/getcwd)

As stated above, getcwd gets the c-string containing the current working directory. It inserts the c-string into `buf` to be used later. The parameter size is the length of the `char*` you pass in as the first parameters. For example, if you created `char directory[250]`, you’d pass in `directory, 250`.

Notes: This function is useful when implementing bash commands such as `cd`, and you need to display the current working directory the user is in. 

Here is a quick example of `getcwd` in action:
```
char buf[1024];
if(!getcwd(buf,1024))
   perror(“problem with getcwd.”);
```

`buf` now contains the path to the current directory you're in, you can output it before your command line prompt to simulate the real bash shell. When you create your own bash shell you will have to implement `cd` with `getcwd` instead of using `exec`.

##getpwuid:
**includes:** `#include <pwd.h>`
          `#include <sys/types.h>`

**declaraton:** `struct passwd *getpwuid(uid_t uid);`

**returns:** If an error occurs `NULL` is returned, otherwise it returns a pointer to a `passwd struct` (seen below)

[man page](http://linux.die.net/man/3/getpwuid)
 
Notes: As you can probably see, `getpwuid` is a bit different from the other syscalls previously mentioned. It takes in the  user’s ID, which is in a numerical form. After that, it will return a pointer to a structure, which contains these fields:
```
struct passwd {
    char   *pw_name;       /* username */
    char   *pw_passwd;     /* user password */
    uid_t   pw_uid;        /* user ID */
    gid_t   pw_gid;        /* group ID */
    char   *pw_gecos;      /* user information */
    char   *pw_dir;        /* home directory */
    char   *pw_shell;      /* shell program */
};
```

The main purpose of this function is  to assist in finding info about the user, and their info. This is particularly useful when implementing things such as `ls` (an assignment in cs-100), and is necessary to implement the `-l` flag for `ls`.

Here’s a quick implementation of `getpwuid`, where `s` is a `stat struct`:
```
struct passwd *pw;
if(!(pw = getpwuid(s.st_uid)))
   perror("there was an error in getpwuid. ");
```

##getgrgid:

**includes:** `#include <sys/types.h>`
          `#include <grp.h>`

**declaraton:** `struct group *getgrgid(gid_t gid);`

**returns:** If an error occurs `NULL` is returned, otherwise it returns a pointer to a `group struct`

[man page](http://linux.die.net/man/3/getgrgid)
 
Much like `getpwuid`, `getgrgid` also returns a pointer to a structure, which contains these fields:
```
struct group {
    char   *gr_name;       /* group name */
    char   *gr_passwd;     /* group password */
    gid_t   gr_gid;        /* group ID */
    char  **gr_mem;        /* group members */
};
```

The main purpose of this function is  to assist in finding info about the group and its info, and much like `getpwuid`, is particularly useful  when implementing things such as `ls` (an assignment in cs-100), and is necessary to implement the `-l` flag for `ls`.

Here’s a quick implementation of `getgrgid`, where s is a `stat struct`:
```
struct passwd *gp;
if(!(gp = getgrgid(s.st_gid)))
   perror("there was an error in getgrgid. ");
```
#Using Linux command easier

The 5 tricks people should know about linux command.
Note: these tricks apply to bash, which is the default shell on most Linux systems.

![Image of Yaktocat](https://octodex.github.com/images/yaktocat.png)



## 1. find ( a powerful tool)

![find: powerful tool](http://funnystack.com/wp-content/uploads/2014/04/Funny-Horse-44.jpg)

The `find` command is used to fetch the positions of  files you want on a Unix or Linux system.  `find` will search any set of directories you specify for files that match the supplied search criteria.  You can search for files by name, owner, group, type, permissions, date, and other criteria.  The search is recursive in that it will search all subdirectories too (very powerful right ? ).  The syntax looks like this

    find where-to-look criteria what-to-do
All arguments to find are optional, and there are defaults for all parts.

    $ find #will display the pathnames of all files in the current directory and all subdirectorie
    $ find . -print
    $ find -print
    $ find .
    (we four are same actually...)
Next we will search the whole system for any files named "foo" and display their pathnames.  `‑name` with the argument "foo" to tell `find` to perform a name search for the filename "foo".

    $ find / -name foo  #give us 3 results
    /home/wpollock/foo 
    /home/ua02/foo
    /tmp/foo



## 2. Special characters (need to know)

![special: need to know](http://blog.zeronana.info/katsuo/wp-content/uploads/2011/05/facebook_smileys.jpg)

Bash has many special characters such as "* & ; | { ! < [ #" (you see, all are special, don't think you know them). 
A commonly used example:
    

    $ find . -iname '*.conf'

Notice the single quotes around `*.conf`. What would happen without it? Bash would interpret the `*.conf` as a glob expression and expand it to all files ending in `.conf` in the current directory. (we don't want this to happen!) This could prevent from looking for all `.conf` files in subdirectories. Remember: we should always quote anything that 
might contain special characters.

It need to be known that only single quotes can prevent every character from being interpreted; double quotes still allow bash to interpret some characters. On the other hand, when working with variables, double quotes come in handy to prevent word splitting(it's useful!), which is often used in scripting. 

You see, when a filename contains whitespace, bash splits the name on that whitespace when you leave variables unquoted. Suppose you have a file named “spaced name.txt, you put it in a variable `filename= spaced name.txt`, and then you try to move it to “unspacedname.txt” by executing `mv $filename unspacedname.txt`. You’ll get the error “mv: target ’unspacedname.txt‘ is not a directory”. This is because mv gets executed like this: `mv spaced name.txt unspacedname.txt`. In other words, mv will try to move two files, “spaced name.txt” to “unspacedname.txt”, 
and fail because moving multiple files to a single destination is only allowed when the destination is a directory. 
Putting double quotes around "$filename" solves this issue.

So you see, quoting is a good habit to prevent your commands and scripts from doing unexpected things. Important message: you can’t quote variables using single quotes, because the dollar sign loses its special meaning between single quotes, and if you ever need to use a literal single quote in some command, you can do so by putting it between double quotes. 





## 3. Process Substitution: save you some time

![efficiency, all I care](http://1funny.com/wp-content/uploads/2009/07/efficient-truck-transport.jpg)

Think of showing differences of two commands quickly? One way is to redirect the output to a temporary file 
for both of them, and diff those files, like this:

    $ find /etc | sort > local_etc_files
    $ find /mnt/remote/etc | sort > remote_etc_files
    $ diff local_etc_files remote_etc_files
    $ rm local_etc_files remote_etc_files

This would tell you the differences between which files are in /etc on the local computer and a remote one. It takes
four lines.  However, it wastes time! Using process substitution, we can do this is just a single line. Amazing!

    $ diff<(find /etc | sort)<(find /mnt/remote/etc | sort)

What does `<(…)` do? It means “run the command inside it, connect the output to a temporary pipe file and give
that as an argument”. To understand this more thoroughly, try running this:

    $ echo <(echo test)

Instead of printing “test”, this will print something like “/dev/fd/63″. You see now that the `<(…)` is actually 
replaced by a file. This file is a stream from which the output of the command inside `<(…)` can be read, like this:

    $ cat <(echo test)

Now this does print "test"! Bash redirects the output of `echo test` to /dev/fd/<something>, gives the path of that
file to `cat`, and `cat` reads the output of `echo` from that file. The shortened `diff` command above does the same (plus it's much shorter), only for two slightly more complicated commands. This technique can be applied in any place where a temporary file is needed, but it does have a limitation. The temporary file can only be read once before it 
disappears. 




## 4. Ctrl+U and Ctrl+Y: backup command

![backup always userful](http://www.yoyoshare.com/wp-content/uploads/images/culture/80.jpg)

Do you know that moment when you’re typing a long command.

    $ cd 1/2/3/4/5/6/7....(# represents super long names "1 = safjslfjsaflfj") 
and then suddenly realize you need to execute something else 
first (Oh, what's the next path...). Everyone hate this! Fortunately, there's a way to fix it. Ensure cursor is at the end of your current command shortcut: `Ctrl+E`, press `Ctrl+U` to get a clean line,

    $ ^E (copy the current command)
    $ ^U (clear the current command)
    $ ls (check the direc you want)
    $ ^Y (paste the older command)
    $ cd 1/2/3/4/5/6/7..... (Yeah, the command is back)
type the other command you need to execute first, execute it, then press `Ctrl+Y` and amazing! Your long command is back on the line. No mouse needed for copying, just quick hotkeys.
Great tricks!!





## 5. A simple calculator

![calculator important sometimes](http://www.mathfunny.com/images/mathpics-mathjoke-mathmeme-pic-joke-math-meme-haha-funny-humor-pun-lol-calculator.jpg)

Sometimes you need to do a calculation that is too much for your brain. When you’re working in a graphic environment, 
you might just fire up kcalc or gcalctool, but tools like that may not always be available or easy to find. Fortunately,
you can do basic calculations within bash itself. 
For example:

    $ echo $((3*37+12))
    123
    $ echo $((2**16-1)) # Two to the power of sixteen minus one; 
    65535
    $ echo $((103/10)) # Outputs 10, as all these operations are integer arithmetic
    10
    $ echo $((103%10)) # Outputs 3, which is the remainder of 103 divided by 10
    3

`$((something))` also allows bitwise operations (what?!), it's actually a syntactic sugar over the `eval` command, and as such it interprets the `^` as a bitwise 
operator. That’s why `**` means  “the power of”. The syntax also supports showing the decimal equivalent of a 
hexadecimal or octal number. 
Here’s an example:

    $ echo $((0xdeadbeef)) 
    3735928559
    $ echo $((0127)) 
    87

For more information, read the bash man page (always a good choice, you can do it on both terminal or online) using man bash and search using "/" for “arithmetic evaluation”. If you want to do floating point calculations, 
you can use `bc`:

    $ echo ‘scale=12; 2.5*2.5′ | bc 
    6.25
    $ echo ‘scale=12; sqrt(14)’ | bc 
    3.741657386773

Note the setting of the scale variable. with `bc`, you can perform floating point operations with any precision you like.
The scale variable controls the amount of decimals behind the dot that are calculated. Using 12 here because "kcalc" 
uses that amount by default, but you can increase or decrease it as you like. Find out more about what bc can do by 
executing `$ man bc`(remember, always a good choice). It even supports more advanced mathematical functions, such as the arctangent or the natural 
logarithm!

![Make life easier](http://www.chronic-illness.org/images/making_life_easier.jpg)

# extending rshell again

### coding requirements

You will make three modifications to your `rshell` project.

1. Your shell must be able to find commands (e.g. `ls` and `tee`) by searching for them using the user's current `PATH` environment variable.  Previously, you were required to only look in the directory `/usr/bin` for these commands, but now you must search many directories.  There are versions of the `exec` function that will perform this search for you automatically (e.g. `execvp`), but you are not allowed to use them.  You must use the `getenv` function to get the current `PATH`, then manually search these directories for the command.

2. The shell should not exit when the user types `^C`.  Instead, the current foreground job should interrupt.

3. Implement the `cd` command, and change your prompt so that it displays the current working directory.  This will require using the `chdir` function.

### submission instructions

You will add this code to your `rshell` project on github.  You may use any number of branches/commits you find convenient.  When finished, merge with the `master` branch and create a tag called `hw4`.

To download and grade your homework, the TA will run the following commands:

```
$ git clone  http://github.com/yourusername/rshell.git
$ cd rshell
$ git checkout tags/hw4
$ make
$ bin/rshell
```

You should run them as well to verify that you've submitted your code successfully.

### project structure

There are no changes to your project structure.

### testing

Again, the tests you choose will be the most important part of your grade.  

### collaboration policy

You MAY NOT look at the source code of any other student.

You MAY discuss with other students in general terms how to use the unix functions.

You are ENCOURAGED to talk with other students about test cases.
You are allowed to freely share ideas in this regard.

You are ENCOURAGED to look at [bash's source code](https://www.gnu.org/software/bash/) for inspiration.

### grading

40 points for using the `PATH` variable

30 points for handling the `^C` signal

30 points for implementing `cd` and the prompt

#### extra credit

You can earn up to 20 points of extra credit by catching the `^Z` signal to pause the foreground process.
You must also implement the `fg` and `bg` commands.
## giving back to the open source community

### requirements

For this assignment, you must give something back to the open source community.  One common problem with open source software is a lack of documentation and easily accessible tutorials.  You will create some.  Future students of this class (and random strangers on the internet) will be using your tutorials to help them learn.

Your tutorial should be between 1000-2000 words.
It should have plenty of code examples and/or pictures illustrating your topic.

#### topic

You are free to choose any topic that will be interesting to future cs100 students.
Here are some past assignments and some suggestions for extending their work:

* [Rashid Goshtasbi and Kyler Rynear's video tutorials](https://izbicki.me/blog/videoguide-for-github-vim-bash.html).
A good topic would be to provide similar video tutorials for another aspect of this class.

* [William Coates's valgrind tutorial](../../../tutorials/valgrind).
A good topic would be to extend this tutorial to cover more of valgrind's features.
A similar tutorial for `gdb` or `cppchecker` (or another tool) would also be nice.

* [Daniel Ting and Katherine Gallaher's syscall tutorial](../../../tutorials/syscalls).
A good topic would be to extend this tutorial to cover more syscalls.
If you choose a topic like this, make sure it stays nice and cohesive and is not just a list of examples.

* [Antoine Guerrero's writeup of how he hacked git to change his grades in this course](https://github.com/aguerrero/Faking-Git-Commits).
If you have a similarly engaging story about some cool programming trick you've done, that would make a good writeup.

* [Brunna Amorim's git cheatsheet](../../lab/lab1-git/git-cheatsheet.md).
A similar cheatsheet for `gdb` or `bash` would make a decent topic.

* [Kevin Nguyen clarified lab 1 by adding pictures to the README file](../../lab/lab1-git).
You can run `git blame` on the file to see exactly what his contributions were.
If one of the labs/assignments was confusing to you, you could extend it in a similar manner.
You will have to work closely with me to make sure the changes are appropriate.

Some other ideas are:

* Think of a topic that initially confused you, and explain it in a way that makes sense to you.
This will help future students master the topic.

* What aspect of computer science do you wish you knew more about?
Research it and writeup your findings.

* The stl and boost libraries have lots of cool features not covered in courses here.
Pick two or three related topics and write them up in a guide.

* Templates are becoming more and more important in C++ programming.
Write a tutorial on how to do template meta programming.
Similarly, write a tutorial on some of the features in the recent C++ 11 or 14 standards.

* Pick an entry in the [international obfuscated C code contest](ioccc.org) and give a writeup explaining how it works.

<!--One simple way to format these tutorials is as a "top ten list."  For example, the project might be "the top ten most useful bash commands."  Then provide ten commands from bash and show how they work and why they're useful.-->

#### writing style

Your writeup must be FUN and ENGAGING.
Informal writing is encouraged.
Imagine your favorite internet blog post and write like that.

In particular, don't write long, drawn-out sentences that use sophisticated verbage because no one wants to read that, especially not cs100 students or random programmers on the internet be kind to us oh and use proper punctuation because reading this sentence totally sucks.
Also, spll chck ur writing and dnt use txt spk b/c I hate tht 5|-|!7.

I highly recommend you visit UCR's writing center.

A short, clear writeup is MUCH better than a long wordy writeup.

### collaboration policy

You may work in a team on this assignment, or you may work individually.
Teams can be of any size, but a larger team must give a larger contribution.
If you choose a topic that overlaps with someone else, I will assign you to the same team.

You are ENCOURAGED to discuss this assignment with anyone, whether they are on your team or not.
In particular, you should get other people to read your drafts!

You must NOT copy and paste material from the internet or any other source.

You MAY use images that you did not create yourself if the use conforms to the images' licensing agreements.

### submission instructions

There are two submissions for this assignment.
The first is part is due on **Thursday, Aug 14**.
In this submission, you must type a short paragraph describing what your tutorial will be about, and who will be on your team.
You should print this document and turn it in in class.
I will use this submission to ensure your topic is appropriate.

Your second submission is due on midnight, **Thursday, Aug 28**.
This will be the final submission for your project.
You must submit your tutorial as a pull request on this repository through github.
Create a folder in this repo called `/tutorials/yoursubject`.
Inside the folder should be at least a file called `README.md` that contains the contents of your tutorial.
You may include other files in this folder, such as images or cpp files, if they are relevant to the tutorial.
I will evaluate the pull request the same as any other pull request into an open source project.

### grading

20 points for your first draft

40 points for technical accuracy

40 points for writing style

Ultimately, grading is entirely subjective on my part.
If I enjoyed reading your writeup, you will get a good score.
If I don't enjoy reading it, you will get a bad score.
Therefore, I recommend you show me drafts of your progress.
I'll give you advice on how to make your writeup more fun.

If you visit the writing center, I will give you +5 points of extra credit on this assignment.
(You'll also get a much higher grade anyways.)
# writing a basic command shell

### coding requirements

Write a command shell called `rshell`.  Your shell will perform the following steps:

1. Print a command prompt (e.g. `$`)

2. Read in a command on one line.  
Commands will have the form: 
```
cmd         = executable [ argumentList ] [ connecter cmd ]
connecter   = || or && or ;
```
where `executable` is an executable program in the `PATH` and `argumentList` is a list of zero or more words.
The connector is an optional way you can run multiple commands at once.
If a command is followed by `;`, then the next command is always executed;
if a command is followed by `&&`, then the next command is executed only if the first one succeeds;
if a command is followed by `||`, then the next command is executed only if the first one fails.
For example:
```
$ ls -a
$ echo hello
$ mkdir test
```
is equivalent to:
```
$ ls -a; echo hello; mkdir test
```
There should be no limit to the number of commands that can be chained together using these operators.

3. Execute the command.
This will require using the syscalls `fork`, `execvp`, and `wait`.
(You can find a tutorial on using these systemcalls (written by previous cs100 students) in the [syscalls-tutorial.md](syscalls-tutorial.md) file located in this same directory.)

4. You must have a special built in command of `exit` which exits your shell.

5. Anything that appears after a `#` character should be considered a comment.
For example, in the command `ls -lR /`, you would execute the program `/bin/ls` passing into it the parameters `-lR` and `/`.  
But in the command `ls # -lR /`, you would execute `/bin/ls`, but you would not pass any parameters because they appear in the comment section.

**IMPORTANT:** Most bash commands are actually executables located in `/bin`.  But some commands are special and are built in to bash.  The `cd` command is the most common example.  So while the `ls` command should "just work" for you, the `cd` command won't.  You'll be adding this feature in a later homework.

**HINT:** Pay careful attention to how you parse the command string the user enters.  There are many ways to mess this up and introduce bugs into your program.  You will be adding more parsing features in future assignments, so it will make your life much easier if you do it right the first time!  I recommend using either the `strtok` function from the C standard libraries or the `Tokenizer` class provide in the [boost library]"(http://www.boost.org/doc/libs/1_36_0/libs/tokenizer/tokenizer.htm).  Students often don't do this section of the assignment well and end up having to redo all of assignment one in order to complete the future assignments.

### submission instructions

Create a new project on github called `rshell`.  Create a branch called `exec`.  Do all of your work under this branch.  When finished, merge the `exec` branch into the `master` branch, and create a tag called `hw1`.

To download and grade your homework, the TA will run the following commands:

```
$ git clone  http://github.com/yourusername/rshell.git
$ cd rshell
$ git checkout hw1
$ make
$ bin/rshell
```

You should ssh into `well.cs.ucr.edu` and run the above commands to verify that you've submitted your code successfully.
If you forget how to use git, two students from previous cs100 courses (Rashid Goshtasbi and Kyler Rynear) made [video tutorials on the git commands needed to submit your assignments](https://izbicki.me/blog/videoguide-for-github-vim-bash.html#tags) via github.

**Do not wait to upload your assignment to github until the project due date.**
You should be committing and uploading your assignment continuously.
If you wait until the last day and can't figure out how to use git properly, then you will get a zero on the assignment.
NO EXCEPTIONS.

### project structure

**IMPORTANT:** The file/directory names below are a standard convention.  You must use the exact same names in your project, including capitalization.

You must have a directory called `src` which contains all the source code files for the project.

You must have a `Makefile` in the root directory.  In the `Makefile` you will have two targets.  The first target is called `all` and the second target is called `rshell`.  Both of these targets will compile compile your program using `g++` with the flags: `-Wall -Werror -ansi -pedantic`.

You must NOT have a directory called `bin` in the project; however, when the project is built, this directory must be created and all executable files placed here.

You must have a `LICENSE` file in your project.  You may select any open source license.  I recommend either GPL or BSD3.

You must have a `README` file.  Calling the file `README.md` is also acceptable if you want to use markdown syntax.  This file should briefly summarize your project.  In particular, it must include a list of known bugs.  If you do not have any known bugs, then you probably have not sufficiently tested your code.  See the testing section below for more details.  I recommend watching [this video tutorial](https://izbicki.me/blog/videoguide-for-github-vim-bash.html#readme) on creating a good `README` file.

You must have a directory called `tests`.  The directory will contain a file called `exec.script` that contains all of the test cases you tried.  You will generate the file using the `script` command, and it must be succinct (i.e. it cannot have unnecessary commands in it).  You should use comments in your script to document what you are testing with each test case.  [This video tutorial](https://izbicki.me/blog/videoguide-for-github-vim-bash.html#script) explains how to use the `script` command.

When you run `rschell` from within `script`, you must run it using the `valgrind` debugging tool.  See the [valgrind-tutorial](valgrind-tutorial) folder in this directory for a tutorial on how to find memory leaks using valgrind.

### coding conventions

Your code must not generate any warnings on compilation.

Your code must pass the `cppchecker` linting tool with no warnings.

Your final executable must have no memory leaks.

Every time you run a syscall, you must check for an error condition.
If an error occurs, then call `perror`.
For examples on when, how, and why to use `perror`, see [this video tutorial](https://izbicki.me/blog/videoguide-for-github-vim-bash.html#perror).

### testing

Proper testing is the most important part of developing software.  It therefore will have a very large impact on your grade. 

It is not enough to simply show that your program works in some cases.  You must show that it works in every possible edge case.  **That means you must try to write test cases that will break your program!**  

**IMPORTANT:** If you do not include a particular test case that we think is important, then we will assume your program fails that test.  It doesn't matter if your program actually passes the test or not.  If you didn't test that case and document it, then your program fails!

If you are unsure if your test cases are sufficient, ask one of the instructors to review them *before the deadline*.

### collaboration policy

You MAY NOT look at the source code of any other student.

You MAY discuss with other students in general terms how to use the unix functions.

You are ENCOURAGED to talk with other students about test cases.
You are allowed to freely share ideas in this regard.

You are ENCOURAGED to look at [bash's source code](https://www.gnu.org/software/bash/) for inspiration.

### grading

30 points for executing commands 

30 points for executing multiple commands on a single line with `;`, `&&`, and `||`

20 points for the `exit` command

20 points for comments

<!--

test cases for part 1 (each worth 5 pts):

* run any command with no params

* run any command with a small number of params

* run any command with a large (>10) number of params

* run both a command in `/bin` and a command in the current directory; for example, run rshell from within rshell

* if command doesn't exist, must print appropriate error message

* verify their parsing works by trying to add lots of spaces between parameters, e.g. `     ls      -a -l        -R`

test cases for part 2: (total 35 points, so possibility of extra credit)

* simple example showing two commands connected with each operator; they must show both the case where the first command succeds and the case where the first command fails. (15 pts)

* an example showing lots of commands chained together (5 pts)

* two examples mixing and matching different operators in one command (10pts)

* parsing example showing that the operators can be right next to each command or they can have spaces separating them; e.g. `ls -l||cat        ; rm -rf *` (5pts)

test cases for part 3: (5 pts each)

* exit all by itself

* exit with parameters passed to it (I don't care if it exits or prints an error)

* exit as a parameter to something else shouldn't exit, e.g. `ls -l exit`

* exit in a chain of commands should exit, e.g. `ls -l; exit`

test cases for part 4:

* comment within a command: `ls -l # this is a comment` (10 pts)

* comment on a line by itself (5 pts)

* comment where `#` touches something else: `ls -l# this is a comment here` (5 pts)

other deductions:

* if they have any binary files in their project, they get -20 points

* if the LICENSE file is missing -5 pts

* if the README is not relatively nice, they get -10 points

* for every syscall that is not error checked they get -5 pts (grading script checks this automatically)

* for every warning during compilation they get -5 pts

* for every memory leak reported by valgrind -5 pts up to -20 points; if valgrind wasn't run then -20 points

* for every error reported by cppchecker, -5 points

extra credit:

* if all of their prompts have the information, then +10pts

* if they provide extra test cases that are particularly nice, they can get up to +10 points

-->

**IMPORTANT:** 
Your project structure is not explicitly listed in the grading schedule above, but if you do not format your project correctly, you will lose points.

**IMPORTANT:** 
Your test cases are also not explicitly listed above, but they are included implicitly in each category.
For example, if you get comments working correctly, but do not test and document that feature, then you will get zero credit for comments.

#### extra credit

Many shells display extra information in the prompt besides just a simple `$`.
For example, it is common to display the currently logged in user, and the hostname of the machine the user is logged into.
My username is `mizbi001`, and if I'm logged into the machine `alpha023`, then my prompt would look like:
```
mizbi001@alpha023$
```
You can get up to 10 points of extra credit if your prompt prints this extra information.
You will need to lookup the functions `getlogin` and `gethostname`.
You must not hard code the username or hostname!
# adding the `ls` command to your shell

### coding requirements

Write a C++ program that implements a subset of the GNU `ls` command.  In particular, you must support: the `-a`, `-l` and `-R` optional flags; and the ability to pass in zero, one, or many files.  Notice that the GNU `ls` command handles files and folders differently, and you must reproduce this functionality exactly.  For a refresher on how to use the `ls` command effectively, you can watch [this video tutorial](https://izbicki.me/blog/videoguide-for-github-vim-bash.html#ls).

To implement `ls`, you must use the `readdir` and `stat` syscalls.  For details on the use of these functions, visit their man pages.

To get you started, the file `ls.cpp` contains code that reads the files in the current working directory.  

### submission instructions

You will add this code to your `rshell` project on github.  Create a branch called `ls` and do all of your work under this branch.  When finished, merge with the `master` branch and create a tag called `hw2`.

To download and grade your homework, the TA will run the following commands:

```
$ git clone  http://github.com/yourusername/rshell.git
$ cd rshell
$ git checkout hw2
$ make
$ bin/ls
```

You should run them as well to verify that you've submitted your code successfully.

### project structure

All source files created for this program should be in your project's `src` folder.  

You will have to modify the `Makefile` to include a target called `ls` which builds your `ls` program.  The `all` target should build *both* `rshell` and `ls`.  Both binaries should be placed in the `bin` folder.  Remember that binaries should not get added to your git repo, and you will be penalized if they are.

### testing

Again, the tests you choose will be the most important part of your grade.  

Remember that the commands `ls -l -R`, `ls -R -l`, `ls -lR` and `ls -Rl` should all do the same thing.  You must consider how these flags interact with the `-a` flag and the optional file parameters.

**IMPORTANT:** If you are unsure if your test cases are sufficient, ask one of the instructors to review them *before the deadline*.

### collaboration policy

You MAY NOT look at the source code of any other student.

You MAY discuss with other students in general terms how to use the unix functions.

You are ENCOURAGED to talk with other students about test cases.
You are allowed to freely share ideas in this regard.

You are ENCOURAGED to look at [GNU ls's source code](https://www.gnu.org/software/coreutils/) for inspiration.

### grading

25 points for the optional file parameters

25 points for the `-a` flag

25 points for the `-l` flag

25 points for the `-R` flag

#### extra credit

The GNU `ls` utility displays different types of files in different colors/fonts using [ANSI escape codes](https://en.wikipedia.org/wiki/ANSI_escape_code).
You will receive up to 15 points extra credit if your `ls` command has this ability.
In particular, you should print directories in blue; executables in green; and hidden files (with the `-a` flag only) with a gray background.
These effects should be combinable.
So if you have a hidden directory, it should be displayed as blue text on top of a gray background.
# adding redirection to your shell

### coding requirements

Extend your `rshell` program so that it properly handles input redirection `<`, output redirection `>` and `>>`, and piping `|`.  
This will require using the Unix functions `dup` and `pipe`.  
The [syscalls tutorial from hw1](../hw1-rshell/syscalls-tutorial.md) also covers these functions.
Of course, you should also be consulting the man pages.

As an example, after this assignment, your program should be able to successfully handle the following command:

```
$ cat < existingInputFile | tr A-Z a-z | tee newOutputFile1 | tr a-z A-Z > newOutputFile2 &
```

**IMPORTANT:** This is a necessary but not sufficient test case.  You must come up with others on your own.

Bash has an extensive syntax for redirection, and you are not required to implement all of it.
But if you're curious, see the [linux documentation project's bash io-redirection tutorial](http://www.tldp.org/LDP/abs/html/io-redirection.html) for details.

### submission instructions

You will add this code to your `rshell` project on github.  Create a branch called `redirect` and do all of your work under this branch.  When finished, merge with the `master` branch and create a tag called `hw3`.

To download and grade your homework, the TA will run the following commands:

```
$ git clone  http://github.com/yourusername/rshell.git
$ cd rshell
$ git checkout hw3
$ make
$ bin/rshell
```

You should run them as well to verify that you've submitted your code successfully.

### project structure

There are no changes to your project structure.

### testing

Again, the tests you choose will be the most important part of your grade.  

You should carefully consider: which redirections can be legally combined together, and which cannot? does order matter?  Also make sure to test that you are parsing the command correctly.

**IMPORTANT:** If you are unsure if your test cases are sufficient, ask one of the instructors to review them *before the deadline*.

### collaboration policy

You MAY NOT look at the source code of any other student.

You MAY discuss with other students in general terms how to use the unix functions.

You are ENCOURAGED to talk with other students about test cases.
You are allowed to freely share ideas in this regard.

You are ENCOURAGED to look at [bash's source code](https://www.gnu.org/software/bash/) for inspiration.

### grading

25 points for input redirection `<`

25 points for output redirection `>` and `>>`

50 points for piping `|`

#### extra credit 1

The bash shell has an additional form of input redirection that let's you redirect from a string instead of a file.  For example, these two commands will give us the same output:

```
$ echo extra credit rocks | cat
$ cat <<< "extra credit rocks"
```

You can receive up to 20 points extra credit for implementing this functionality.

#### extra credit 2

The bash shell let's you perform output redirection on whatever file descriptors you want by placing a number before the `>` command.
For example,
```
$ g++ main.cpp 2> errors
```
will direct stderr (which is where g++ prints error messages) to the file errors.
If you implement this syntax for any file descriptor and both `>` and `>>`, you will get up to 20 points extra credit.
# hacker reading

There are a lot of books that have made it into the "hacker culture."  Reading them is a fun way to get better at programming.  I will give you up to 20 points of extra credit if you read any of the following books and discuss it with me:


1.  (free) Eliezer Yudkowsky's [Harry Potter and the Methods of Rationality](http://hpmor.com)

2.  Douglas Hofstadter's *Gödel, Escher, and Bach*.

3.  Peter Seibel's *Coders at Work*

4.  Jessica Livingston's *Founders at Work*.

You may also suggest another book that you think has hacker value.  If I agree, I'll add it to the list.

**IMPORTANT:** If you've already read one of these books, that doesn't count.  Read a different one.
## online communities

Participating in online programming communities is a fun way to expand your programming knowledge.  I want to encourage you to participate.  Here are four ways you can get extra credit from participation:

1. If you have a project on github with more than 10 stars, you will get 10 points extra credit.  Stars from fellow UCR students count as only 1/4 a star.

2. If you have a stackoverflow account with more than 100 points, you will get 10 points extra credit.  If you have a stackoverflow account with more than 1000 points, you will get an *additional* 20 points extra credit.  You do not need to have created the account or earned the points during this quarter.

3. If you submit something to the front page of [/r/programming](http://www.reddit.com/r/programming) that gets more than 200 upvotes, you will get 10 points extra credit.

4. If you submit something to the front page of [hacker news](http://news.ycombinator.com) that gets more than 30 upvotes, you will get 10 points extra credit.
# play a game for homework!

*This is an optional extra credit homework assignment.*

In this homework assignment, you will play a game!  The game is at http://vim-adventures.com.  By playing the game, you will get better at using the `vim` commands.

The first three levels are free.  The remaining levels require you to pay $25 to the website.  You are not required to pay this money and complete the game.  By default, this assignment will not be factored into your grade.

If you do complete the game, however, then you will receive a 100% on this homework assignment and the assignment will be included in your grade.
# bounty

Major companies like Google [offer monetary rewards](http://www.google.com/about/appsecurity/reward-program/) if you find bugs in their software.
These programs are often called "bug bounties."

We'll set up a bug bounty system in this course.
For every mistake that you find and correct in this course material, I will give you extra credit.
For example:

1. If you find a typo on any page, then create a pull request that fixes the typo.

2. If part of a homework assignment is worded unclearly, then create a pull request that fixes the wording.

3. If you discover a way to change your grade without me finding out, let me know.
You won't get in trouble.
I'll give up to 200 points extra credit for this, depending on how clever/severe your attack is.

Those are just examples.
If you can think of other ways to improve the course, let me know!
# quiz 2: data structures review

Pick any program you want.  Print out a screenshot.  On the back of the printout list 20 examples of data structures, abstract data types (ADTs), or algorithms that might be used internally in the program.  Your examples must be present in the screenshot.  You are only allowed to pick examples from the following lists, and you must provide at least one example for each entry in the list.

Abstract data types and data structures:

1. The stack ADT

2. The queue ADT

3. The binary search tree data structure (you must clearly identify what would happen to the program if the tree were not balanced)

4. The heap data structure

5. The map ADT (you must clearly identify what the keys and values are)

6. The set ADT

7. The priority queue ADT

8. The graph ADT (you must clearly identify what the nodes and edges are)

Algorithms:

1. Sorting

2. Dijkstra

3. Primm/Kruskal
# how to be a spammer

You should complete this lab using pair programming with a new partner.

### coding instructions

In this lab, we're going to learn to send spam emails.  It turns out that with the [Simple Mail Transfer Protocol (SMTP)](http://en.wikipedia.org/wiki/Simple_Mail_Transfer_Protocol), you don't need to know someone's password to send email from their account!  Anyone can send emails from anyone elsse's account!

First, you're going to practice sending these emails.  Then, you're going to write a bash script to automate the process.

**IMPORTANT:** Don't use this for evil!  It will get your cs account suspended and could even get you arrested!

#### spoofing an email

First, telnet into the local SMTP webserver:

```
telnet email.cs.ucr.edu 25
```

Telnet is a simple command line utility that let's us send commands over the network.  Whatever you type in gets sent over the network to the server you're connected to.

Now, type the following commands:

```
helo whitehouse.gov
mail from: presidentobama@whitehouse.gov
rcpt to: yourpartnersemail@server.com
data
Subject: I'm the president!
I order you to submit correct homework!
.
```

The dot at the end is very important.  It must be on a line all by itself.  That's what tells the server that the email message is over.

**IMPORTANT:** Our server is configured so that you must be on the computer science network to have access to it.  You cannot do this from home (unless you ssh in).  There are, however, many poorly configured servers on the internet that let anyone access them to send email from.

#### automate the process using bash

In this part of the lab, you're going to write a bash script that sends spam to your friends.  The script should be called `sendspam.sh`.  It will take two parameters.  The first is the email address of the recipient, and the second is the email of the sender.  Your script will read stdin to get the body of the email, and the subject line will always be `This email is spam!`.

For example, if you were a jerk, you could spoof an email from me to one of your classmates using the command:

```
$ ./spam.sh classmate@ucr.edu mike@izbicki.me
Class is cancelled forever.  
There is no more homework.
Everyone get's an A++++++.
:)
^D
```

### deliverables

When finished, demo your working code for the TA.  
# Unix `fork`
 
You should complete this lab using pair programming with a new partner.

### coding instructions

Write a program that uses `fork` to create 4 processes.  Each process should:

1.  Pick a letter in `ABCD` and print it 10000 times.  Each process should pick a different letter.  Flush the output after printing every character.

2.  Print every process's PID when it is created.

Be sure you do not leave any processes running.  You can check this with the command, `ps -aux`. 

**IMPORTANT:** A parent process must `wait` for each child after it has terminated, or that child will become a [zombie](https://en.wikipedia.org/wiki/Zombie_process).

Run your program multiple times and see that the output is different each time.

#### fun with fork bombs

The `fork` system call can be used to implement a simple [denial of service](https://en.wikipedia.org/wiki/Denial-of-service_attack) attack called a "fork bomb."  Find the `C` code for a fork bomb on the [wikipedia page](https://en.wikipedia.org/wiki/Fork_bomb).  Compile and run the fork bomb... you can defuse it?!

### deliverables

When finished, demo your working code for the TA.  

﻿# cstring functions

You should complete this lab using pair programming with a new partner.

### coding instructions

In this lab you will implement your own versions of the functions found in the cstring library.  Create a header file `myCString.h` which contains your implementation of the following functions: 

1. `strcpy`
1. `strncpy`
2. `strcat`
2. `strncat`
3. `strcmp`
4. `strchr`
5. `strstr`
6. `strlen`

You must write each function from scratch.  You CANNOT use the functions provided within the cstring library to implement your own; however, using your own implementation of one function in another, such as `strlen` in `strcpy`, is fine.   A simple way to avoid conflicts with cstring is to give a different name to your own functions (e.g., `my_strcpy`, `my_strcmp`).

You will need to look up the man pages for each of these functions to make sure they work just like the versions in the library.  

**IMPRTANT:** You should be implementing the cstring versions, NOT the string versions (i.e. the parameters should be `char*` and not `std::string`).  Your function signatures should be exactly the same as the standard cstring versions.  You should not implement your own string class.

**IMPORTANT:** None of these functions allocate memory.  They assume the user calling them has already allocated the correct amount of memory.  If you are using the `new` or `malloc` in any of these functions

Write a `main.c` file that tests your library.  You must use the C compiler `gcc` to compile your program.  You are not allowed to use `g++`.  This will ensure you are not using any C++ features in your code. You must have detailed tests that cover every possible edge case.

### deliverables

When finished, demo your working code for the TA.  
﻿# cstring functions

In this lab you will implement your own versions of the functions found in the cstring library.  Create a header file “myCString.h” which contains your implementation of the following functions: 

1. `strcpy`
1. `strncpy`
2. `strcat`
2. `strncat`
3. `strcmp`
4. `strchr`
5. `strstr`
6. `strlen`

You must write each function from scratch.  You CANNOT use the functions provided within the cstring library to implement your own; however, using your own implementation of one function in another, such as `strlen` in `strcpy`, is fine.   A simple way to avoid conflicts with cstring is to give a different name to your own functions (e.g., `my_strcpy`, `my_strcmp`).

You will need to look up the man pages for each of these functions to make sure they work just like the versions in the library.  

**IMPRTANT:** You should be implementing the cstring versions, NOT the string versions (i.e. the parameters should be `char*` and not `std::string`).  Your function signatures should be exactly the same as the standard cstring versions.  You should not implement your own string class.

Write a `main.cpp` file that tests your library.  You must have detailed tests that cover every possible edge case.
# timing io operations

You should complete this lab using pair programming with a new partner.

### coding instructions

In this lab, you will implement a version of the `cp` command line program that copies files from one location to another.  You will use three different methods for copying the files and compare their performance.  The methods are:

1. Use the `in.get(char)` and `out.put(char)` C++ functions to copy the input file to the output file one character at a time.

2. Use the Unix system calls `read()` and `write()` to copy the input file to the output file one character at a time.
  
3. Use the Unix system calls `read()` and `write()` to copy the input file to the output file one buffer at a time.  The buffer should be of size `BUFSIZ`, which is declared in the `stdio.h` include file.

Your final program should have two required arguments (the input and output file) and one optional argument.  If the optional argument is not given, then copy the files using the most efficient of the three methods above.  

If the optional argument is given, then your program will copy the file using each of the three methods, time how long each method takes, and report the results to stdout.  You must show wallclock, user, and system run times.You may use the given `Timer.h` file to measure the run times.  

In order to determine which method is fastest, you'll need to test them on a large file.  Otherwise, the performance differences will not be noticeable.  The file `/usr/share/dict/linux.words` should be sufficiently large.

**IMPORTANT:** If the file you are copying to already exists, your program must print an error.  The built-in `cp` will check to see if the second file is a directory.  If it is, then `cp` will copy the file into the directory.  You do NOT have to implement this feature.

**IMOPRTANT:** The built-in `cp` program can support copying entire directories using the `-r` flag.  You do not need to implement this feature.  You should simply print an error message if the first argument is a directory.

### deliverables

The deliverables for this lab are more complicated than for previous labs.  We want your `cp` program added to your `rshell` project on github.  Source code should go in the `src` folder, and the `Makefile` needs to be modified to build the `cp` program and put it in the `bin` folder.  This is the same setup we had for the `ls` command you wrote for homework. 

There is one catch though: you are not allowed to commit the code to your own repository.  Your partner must fork your repo, commit the code, and issue a pull request making all the changes.  I want you to get practice contributing to other people's open source projects and having other people contribute to your own projects.
# learning to use gdb

You should complete this lab using pair programming with a new partner.

### instructions 

You're a progamming intern at the defense contractor HBHairy.
Your main job is to repackage a bunch of open source software.
HBHairy resells it to the navy for a premium.
But your CEO [managed to upset the hacker group Anonymous](http://www.networkworld.com/article/2183906/malware-cybercrime/anonymous-attack-on-hbgary-federal-didn-t-ruin-us--says-hbgary-ceo.html).
They've hacked into HBHairy's internal company servers and changed the code for the `ls` program!
Your job is to find and fix the changes they've made.

If you had been using version control, then this would be really easy.
You'd just run `git checkout` to go back to the last known good commit.
But your boss is an idiot, so none of the source code was version controlled.
Instead, you must use the `gdb` debugger to track down all of the bad code.

You will find all the source code in the file `hbhairy-utils.tar.xz`.
Lucky for you the hackers left the `INSTALL` file intact.

Known bugs:

* The first thing printed by `ls` is always `(null)`.

* `ls` prints the text `!!!WE ARE LEGION!!!`

* `ls` prints the text `lolololololololololololololololololololololol`

* Running `ls` turns the terminal red.

* Running `ls` prints the files separated by commas rather than the default behavior of printing a nice table.

* The `-a` flag no longer prints the `.` and `..` files as it is supposed to.  (HINT: `-a` is behaving like `-A`.)

* Running the command `ls --help` just prints the Anonymous logo mask and doesn't print any help information.

* Running `ls -R` quotes a Monty Python insult at you.

* Running `ls -R` segfaults.

* Running `ls -l` segfaults.

### deliverables

You must demonstrate your fixed code to the TA.
Your score on this lab will be 2 points for attendance, plus 1 point for each bug you fix.
It is possible to get a 12/10 on this lab.

<!--

TA Message:

The original `ls.c` file is now called `omfg.c`.
If you run the command:

```
$ diff ls.c omfg.c
```

You can see where all the changes were made to the source.
The file `system.h` has a few macros added to it as well.

-->
# using git and github

We will not be using ilearn in this class.  Instead, we will be using a version control system called `git`.  Version control systems are widely used in industry and in open source projects.  They are the tool that lets many programmers work together on large, complex software.  I don't know what programming language you will use at your future job (it may not even exist yet!), but I guarantee you will be using version control.

In this lab, you will first learn the basics of how to use `git` and github.  Then, we will discuss how to use these tools to access your grades and submit assignments.

### creating your first repo (and some basic unix commands)

Open a terminal, and `cd` into the directory you will be doing your cs100 work in.  Then create a folder named `firstrepo` and `cd` into it:

```
$ mkdir firstrepo
$ cd firstrepo
```

This folder will be the home of your first git repository.  Run the following command to initialize it:

```
$ git init
```

All the information for the git repository is stored in a hidden folder called `.git`.  The folder is hidden because it begins with a `.`.  By default, the `ls` command does not display these hidden folders.  To display them, you must pass the `-a` flag.  Compare the results of the following two commands:

```
$ ls
$ ls -a
```

Now we are ready to add some files into our repo.  Every repo in this class must have a `README` file.  Create the file using the following command:

```
$ touch README
```

The `touch` command is a standard unix command.  If the input file does not already exist, `touch` creates an empty file with that name.  If the file does already exist, it updates the file's timestamp to the current time.  The `ls -l` command displays the full information about each file in the current directory.  Run the following commands:

```
$ ls -l
$ touch README
$ ls -l
```

Notice how the timestamp in the first `ls` is different than the timestamp in the second `ls`.

We've created our first file, but git doesn't know about it yet.  Run the command:

```
$ git status
```

In the output, there is a section labeled "untracked files."  Notice that the `README` file is in this section.  We need to add it into our project using the command:

```
$ git add README
```

Now, when we run `git status`, there is a section labeled "Changes to be committed" with the `README` file underneath it.

Whenever we finish a task in our repo, we "commit" our changes.  This tells git to save the state of the repo so that we can come back to it later if we need to.  Commit your changes using the command:

```
$ git commit -m "my first commit"
```

Every commit needs a "commit message" that describes what changes we made in the repo.  Writing clear, succinct, informative commit messages is one of the keys to using git effectively.  In this case, we passed the `-m` flag to git, so the commit message was specified in the command line.  If we did not pass a flag, then git would have opened the vim editor for us to type a longer commit message.  Whether or not you use the `-m` flag is purely a matter of style, but in my experience, it's usually easier to add the flag.

Let's add some actual code to our project.  Create a file `main.cpp` with the following code:

```
#include <iostream.h>

int main()
{
    std::cout << "hello git" << std::endl;
    return 1;
}
```

Compile and run the code:

```
$ g++ main.cpp
$ ./a.out
```

Then add it to the repo and commit your changes:

```
$ git add main.cpp
$ git commit -m "added the first code"
```

**IMPORTANT:**  Notice that we only added the `main.cpp` file to our repo, and did not add `a.out`.  Never add executable or object files to your git repo!  Only add source files!  Tracking executables uses LOTS of disk space, and makes the repo cluttered and hard to read.  If we ever see these files in your git repos, your grade on the assignment will be docked 20%.

Let's make one more commit so we'll have something to play with.  Run the command:

```
$ echo "This program prints \"hello git\"" > README
```

Remember that `echo` prints to `stdout` and the `>` does output redirection.  So this command changes the contents of the `README` file.

The command `cat` prints the contents of a file to `stdout`.  Verify that your `README` file has changed using the command:

```
$ cat README
```

Now run:

```
$ git commit -m "modified the README"
```

Uh oh!

We got an error message saying: "no changes added to the commit".

Every time you modify a file, if you want that file included in the commit, you must explicitly tell git to add the file again.  This is because sometimes programmers want to commit only some of the modified files.  We can commit the changes by:

```
$ git add README
$ git commit -m "modified the README"
```

### traveling through time

Okay!  

Now we're ready to take advantage of git's power.

Run the command:

```
$ git log
```

This gives us a history of all our commits.  For each commit, there are four pieces of information.  The first is the commit identifier.  This is a long hexadecimal sequence, for example: `093d5fa3c60ce204b6ddba86d4f9c355b4856f10`.  (Technically, this is a [SHA1 hash of your commit](https://en.wikipedia.org/wiki/SHA1).  This hash is "cryptographically secure", meaning that it is practically guaranteed to be unique.  Take cs165 to find out more!)  Next is the author of the commit, the date of the commit, and the commit message.

Sometimes, we want to look at what the state of our repo was in a previous commit.  There are many reasons this is useful.  For example, maybe your latest changes broke some functionality and you want to see what working code looked like.  Or, maybe a user of your code reported a bug, but they're using an old version of the software; we need to look at the old version of the code to reproduce the bug.

We can inspect the previous state of our code using the `git checkout` command.  This command takes as a parameter the hash of the commit we want to inspect.  For me, the hash of "my first commit" is `a20aef2096d98ab53d1495f823409e2cc8cd54b9`.  So to inspect that commit, I would run:

*(You should replace the hash below with the hash of your "my first commit")*

```
$ git checkout a20aef2096d98ab53d1495f823409e2cc8cd54b9
```

Now let's see what happened.  Run the command:

```
$ cat README
```

The file is empty again!

Now run:

```
$ ls -l
```

Your `main.cpp` file disappeared!  All of the files tracked by git have returned to their previous state.  But notice that your `a.out` program still exists unmodified.  (Run it just to be sure.)  This file was never tracked by git, and so it is unmodified when we checkout different commits.

Let's restore all those changes.  Run the command:

```
$ git checkout master
```

And verify that our changes have been restored:

```
$ cat README
$ ls -l
```

### git repos are trees

Another important use of version control systems is working with multiple versions of the same project at once.  This is VERY useful.  Also, you'll be required to do this in future homework assignments (and all throughout your illustrious careers), so pay attention!

Every version of our repo is called a "branch."  A project can have many branches, and every branch can be completely different than every other branch.  List the branches in your current project using the command:

```
$ git branch
```

This should list just a single branch called "master."  This branch was created for you automatically when you ran the `git init` command.  

One way to think of branches is as a nice label for your commit hashes.  Your "master" branch currently points to your commit with the message "modified the README."  That's why when we ran `git checkout master` above, it restored our project to the state of that commit.  We could also have used `git checkout [hash]`, if you replaced `[hash]` with the appropriate hash value.  But that's much less convenient.  When you use `git checkout` in the future, you will usually be using it on branch names.

From now on, we'll be drawing pictures of our git repos so you can visualize what's going on.
Currently, our repo looks like:

<p align=center>
<img src="images/3.png?raw=true">
</p>
The purple boxes represent all the commits we've done, and the blue box represents a branch.

Every time we add a new feature to a project, we create a branch for that feature.  Let's create a branch called `userinput` in our project by:

```
$ git branch userinput
```

Verify that our branch was created successfully:

```
$ git branch
```

You should see two branches now.  There should be an asterisk next to the master branch.  This tells us that master is the currently active branch, and if we commit any new changes, they will be added to the master branch.  (That is, `master` will change to point to whatever your new commit is.)

Our repo tree now looks like:

<p align=center>
<img src="images/4.png/raw=true">
</p>

Switch to our new branch using the command:

```
$ git checkout userinput
```

Now run:

```
$ git branch
```

and verify that the asterisk is next to the `userinput` branch.
Since the only thing you did was switch branches, the repo tree looks almost the same.
The only difference is the asterisk has moved.

<p align=center>
<img src="images/5.png?raw=true">
</p>

Let's modify our `main.cpp` file so that it asks the user their name before saying hello:

```
#include <iostream>
#include <string>

int main()
{
    std::string name;
    std::cout << "What is your name?" << std::endl;
    std::cin >> name;
    std:::cout << "Hello " << name << "!" << std::endl;

    return 1;
}
```

We commit our changes to the current working branch the same way we committed them before:

```
$ git add main.cpp
$ git commit -m "added user input"
```

Before this commit, the `userinput` and `master` branches were pointing to the same commit.  When you run this command, the `userinput` branch gets updated to point to this new commit.
Now your tree looks like:

<p align=center>
<img src="6.png?align=true">
</p>

Let's verify that our changes affected only the userinput branch and not the master branch.  First, checkout the master branch, then cat the `main.cpp` file, then return to the user input branch.

```
$ git checkout master
$ cat main.cpp
$ git checkout userinput
```

We're not done with this feature yet.  Whenever you add a feature, you also have to update the documentation!  Properly documenting your code will be a huge part of your grade in this course!

Update the `README` file with the command:

```
$ echo "This program asks the user for their name, then says hello." > README
```

And add it to the repo:

```
$ git add README
$ git commit -m "updated README"
```

Your repo tree now looks like:

<p align=center>
<img src="images/7.png?raw=true">
</p>

The way branches are used out in the real world depends on the company you work for and the product you're building.  A typical software engineer might make anywhere from one new branch per week to 5 or more new branches per day.  

### fixing a bug

Wait!

While we were working on our `userinput` branch, someone reported a bug in our `master` branch.  In particular, the main function in our master branch returns 1, but a successful program should return 0.  In UNIX, any return value other than 0 indicates that some sort of error occurred.  

To fix this bug, we first checkout our master branch:

```
$ git checkout master
```

Then create a `bugfix` branch and check it out:

```
$ git branch bugfix
$ git checkout bugfix
```

Here's the tree.
Notice that the `bugfix` branch starts where the `master` branch was because we switched to `master` before creating `bugfix`.

<p align=center>
<img src="images/8.png?raw=true">
</p>

Now we're ready to edit the code.  Update the `main` function to return 0, then commit your changes:

```
$ git add main.cpp
$ git commit -m "fixed the return 1 bug"
```

Since you made the commit on the `bugfix` branch, your tree splits off in another direction and now looks like this:

<p align=center>
<img src="images/9.png?raw=true">
</p>

### merging branches

We want our users to get access to the fixed software, so we have to add our `bugfix` code into the `master` branch.  This process is called "merging."

In this case it is a simple procedure.

First, checkout the `master` branch:

```
$ git checkout master
```

Then run the command:

```
$ git merge bugfix
```

This automatically updates the modified files.

Your tree will now look like this:

<p align=center>
<img src="images/10.png?raw=true">
</p>

Using branches like this to patch bugs is an extremely common usage pattern.  Whether you're developing open source software or working on facebook's user interface, this is the same basic procedure you will follow. 

With real bugs on more complicated software, bug fixes won't be quite this easy.  They might require editing several different files and many commits.  It might take us weeks just to find out what's even causing the bug!  By putting our changes in a separate branch, we make it easy to have someone fixing the bug while someone else is adding new features.

### merge conflicts

Our `userinput` feature is also ready now.  We've tested it and are sure it's working correctly.  It's time to merge this feature with the `master` branch.  Run the commands: 

```
$ git checkout master
$ git merge userinput
```

Ouch!  

We get an error message saying:

```
Auto-merging main.cpp
CONFLICT (content): Merge conflict in main.cpp
Automatic merge failed; fix conflicts and then commit the result.
```

This error is called a "merge conflict" and is one of the hardest concepts for new git users to understand.  Why did this happen?

In our `bugfix` branch above, git automatically merged the `main.cpp` file for us.  It could do this because the `main.cpp` file in the `master` branch did not change after we created the `bugfix` branch.  Unfortunately, after we merged the `bugfix` branch into master, this changed the `main.cpp` file.  Now when git tries to merge our changes from the `userinput` branch, it doesn't know which parts to keep from `uesrinput`, and which parts to keep from `bugfix`.  We have to tell git how to do this manually.

If you inspect the contents of the `main.cpp` file, you'll see something like:

```
#include <iostream>
#include <string>

int main()
{
<<<<<<< HEAD
    std::cout << "hello git!" << std::endl;
    return 1;
=======
    std::string name;
    std::cout << "What is your name?" << std::endl;
    std::cin >> name;
    std:::cout << "Hello " << name << "!" << std::endl;

    return 0;
>>>>>>> userinput
}
```

As you can see, the file is divided into several sections.  Any line not between the `<<<<<<<<` and `>>>>>>>>` lines is common to both versions of `main.cpp`.  The lines between `<<<<<<<< HEAD` and `=======` belong only to the version in the `master` branch.  And the lines between `=======` and `>>>>>>>> userinput` belong only to the `userinput` branch.

The key to solving a merge conflict is to edit the lines between `<<<<<<<` and `>>>>>>>` to include only the correct information from each branch.  In our case, we want the `return` statement from the `master` branch, and all of the input/output from the `userinput` branch.  So we should modify the `main.cpp` file to be:

```
#include <iostream>
#include <string>

int main()
{
    std::string name;
    std::cout << "What is your name?" << std::endl;
    std::cin >> name;
    std::cout << "Hello " << name << "!" << std::endl;

    return 1;
}
```

Once we have resolved this merge conflict, we can finalize our merge.  We first tell git that we've solved the conflict by adding the conflicting files, then we perform a standard commit:

```
$ git add main.cpp
$ git commit -m "solved merge conflict between userinput and bugfix branches"
```

And your tree looks like:

<p align=center>
<img src="images/11.png?raw=true"
</p>

As you can see, resolving merge conflicts is a tedious process.  Most projects try to avoid merge conflicts as much as possible.  A simple strategy for doing this is using many small source files rather than a few large files.  Of course, in most projects merge conflicts will be inevitable.  That's just the reality of working on large projects with many team members.

### exercise

Given the same repo above, draw the tree that results after running the following commands.
You will have to submit this to the TA before the end of lab.

```
$ git branch -d userinput
$ git branch -d bugfix
$ echo "everything is awesome" > README.md
$ git add README.md
$ git commit -m "changed the README"
```

You should check the [git cheatsheet](git-cheatsheet.md) to figure out what the `git branch -d` command does.

## enrolling in this course

We will not be using ilearn in this course.  We will be using git and github to manage everything.  This will give you practice working with open source software.  To enroll in this course, you will follow the same steps that you would do to contribute to an open source project.

### subscribing to the course

If you do not already have a github account, you will need to create one.  Go to http://www.github.com and register an account.  Your github account does NOT need to be the same as your cs account.  For example, my account is just my full name `mikeizbicki`.  Feel free to get creative and pick something fun.  If you already have a github account, you do not need to register a new one.

Return to http://github.com/mikeizbicki/ucr-cs100. At the top of the page there is a button labeled `Watch`:

<p align="center">
  <img src="https://github.com/thekevinlemon2/ucr-cs100/blob/master/assignments/lab/lab1-git/images/watch.png?raw=true"/>
</p>

Click this button to become a follower of the repository. Anytime we update the course with new information or announcements, you will be notified by email.

Return to http://github.com/mikeizbicki/ucr-cs100.  On the right hand side of the page is a button labeled `issues`:

<p align="center">
  <img src="https://github.com/thekevinlemon2/ucr-cs100/blob/master/assignments/lab/lab1-git/images/issues.png?raw=true"/>
</p>

Click this button.  At the top of the page will be a green button labeled `new issue`.  Whenever you have a question with the course, you should NOT email the instructors directly.  Instead, you should submit an issue here.  This will notify following the project (both instructors and students) about your question, and anyone can answer it.  We will be using this system for communicating instead of piazza.

### forking your repo

Return to http://github.com/mikeizbicki/ucr-cs100.  In the top right corner of the page is a button labeled `fork`:  

<p align="center">
  <img src="https://github.com/thekevinlemon2/ucr-cs100/blob/master/assignments/lab/lab1-git/images/fork.png?raw=true"/>
</p>

Click this button to create a new version of this repository in your own GitHub account.  This is where all your grade information will be stored.  (Keep reading for details!)

By default, you are the only person with write access to your new repository.  You must give all the instructors write access so we can update your grades.  Visit the page:

*(Use your actual github username below)*

```
https://github.com/examplestudent/ucr-cs100
```

Click the button on the right hand side labeled `settings`.

Click the button on the left hand side labeled `collaborators`.

This should bring up a menu that lets you add collaborators.  Everyone you add here has full write access to the repo.  Add all of the course instructors as collaborators.  Our github accounts are: `MikeIzbicki` and `bmars003`.

Click the button on the left hand side labeled `collaborators`:

<p align="center">
  <img src="https://github.com/thekevinlemon2/ucr-cs100/blob/master/assignments/lab/lab1-git/images/collaborators.png?raw=true"/>
</p>

This should bring up a menu that lets you add collaborators.  Everyone you add here has full write access to the repo.  Add all of the course instructors as collaborators.  Our GitHub accounts are: `MikeIzbicki` and `bmars003`. 

**IMPORTANT:** The file `GRADES.md` in this repo contains detailed information about how your grades will be stored in this repo.  Finish completing this lab, then go back and read this file.

### add your information to the course page

To finalize your enrollment in this class, you will change this repo to include your student information.

For open source projects, it's common that only a small number of people have write permissions to the repo.  In this repo, only the TA and I have write permission!  If I gave all you students write permission, someone would just delete all the homework!

Because you don't have write permission to this repo, adding changes will involve a few extra steps.  Here's a quick outline:  You first add the changes to your forked repo. Then you issue a "pull request."  This sends a message to the owners of the repo (in this case the course instructors) that you've made some changes you think we should add.  The instructors will then review your commit and make sure it follows the guidelines.

You've already forked the repository, so we can skip that step.  In order to modify the forked repo, you'll need to copy it onto your local computer.  This process is called "cloning" a repository.  Run the command:

*(Use your actual github username below)*

```
git clone https://github.com/examplestudent/ucr-cs100.git
```  

This will create a folder in your current working directory called `ucr-cs100`.  This folder contains the contents of the repo you just cloned.

Now you're ready to start editing the repo.  

Create a file in the `studentinfo` directory with the same name as your **CS account** and no file extension.  Edit this file so that the first line is your first and last name, and the second line is your github account name.  The automated grading system will be using this file to get your account information, so it is important that you get the format correct!  I've created an example with my info in the `mizbi001` file.

Add and commit your changes like normal.  You may want to review the commands from the previous sections.

We have two more steps to get your changes added into the original repository.  First, we have to update your forked repository on the github servers.  Run the command:

```
git push origin master
```

This "pushes" all the changes you've made back up to github.

Now you need to issue a "pull request" to this repository.  This is done through the github web server and not through the command line.  Visit your forked project's webpage at: http://www.github.com/yourusername/ucr-cs100.  There is a dull gray button labeled "pull request."  Pressing this button will send you to a form where you fill out a message describing what you've changed in the code.  You merge message should be "enrolling in cs100".

Once you issue your pull request, the TA will review your contribution and add it to the repository.  Congratulations!  You've just made your first contribution to open source software and are officially enrolled in the class!

You will use git extensively in this class to submit your assignments and receive feedback.  See the file called `GRADES.md` in the root folder of this project for detailed instructions.

## references

We've only scratched the surface of what the git command has to offer.  You should be able to get by in this course using just these commands.  But if your looking for more info, here's some good links:

This webpage is a reference for the most common and useful git commands.

http://rogerdudler.github.io/git-guide

This is a full book on how to use git effectively.  It also has videos of programmers in action.

http://www.git-scm.com/doc

## deliverables

Tell the TA once you have issued your pull request.
Cheat Sheet
===========
###Git and GitHub

#####SETUP GIT

After installing Git, you can make modifications to customize the environment and identify yourself in it. You just need to make these changes once.

```
$ git config --global user.name [your username]
```
This command will set the username that will appear on your commit transactions.


```
$ git config --global user.email [email address]
```
This command will set the email of your commit transactions.


```
$ git config --list
```
Command to list all the settings of your Git, including username and email.


#####USING HELP

If you need help to use some Git command, you can always use the command `git help`. There are three ways to use it:
```
$ git help [command name]
$ git [command name] --help
$ man git-[command name]
```
For example, if you need some help with the config command, you can use:
```
$ git config --help
```


#####CREATE A NEW REPOSITORY

You can create a Git project using two different methods: By creating a new repository in an existing local project or directory or by cloning an existing remote repository.

```
$ git init
```
With `git init`, you will create a new Git repository on the project that you are working on. This project can be a new one (that doesn’t have anything on it) or it can be a project that already exists but you want to use version control on it. You should run this command on the folder of your project.


```
$ git clone [url]
```
With `git clone`, you will download a copy of a Git project that already exists. For example, you can take an url from a GitHub project that you want to contribute to, and clone it. This will create a new folder with all the project on it, in the current directory.


#####MAKE CHANGES

After creating a new repository, you can start doing your project. To keep the repository up to date, you have to commit the changes that you made on your local machine.

```
$ git status
```
This command will list for you all the files that were modified since the last time you commit something. For example, you made some changes in a `main.cpp` file of your project. If you have not committed yet, the command `git status` will show it for you.


```
$ git add [file]
````
With the `git add` command, the files that you changed will be ready to commit.

```
$ git rm [file]
```
If you want to remove a file from your project, you also have to remove it from Git so you can commit your changes.


```
$ git diff
```
`git diff` will compare what is in your working directory with what is in your staging area (the things you changed, but have not used the command `git add` yet). The result tells you the changes you’ve made that you have not staged.


```
$ git commit -m [descriptive message]
```
You will use this command to commit the changes that you made and staged. After using `git add` on the files that you wanted to add, you will use `git commit -m "..."` to commit it. The `-m` flag will set the commit message.


```
$ git commit
```
If you want to use the command `git commit` without the `-m` flag, the editor of your choice will be launched and you can type your commit message there. Your commit must have a message. If you don't do it, the commit will be aborted.


```
$ git tag [tag name]
```
The git tag command will give a name (tag) to the last commit that you made. This is helpful because you can access this commit later, even if you already commit something else.


#####GROUP CHANGES
Name a series of commits and combine completed efforts. 

Using Git, you can work with multiple versions of the same project at the same time. This is called branching. Every project can have many branches (versions) and they can be completely different from each other. This is very useful when you want to add a new feature to a project that is already working, and to not ruin it, you can just make another branch, work on your new feature in it, and when the feature is ready you merge the new branch with the origin.

```
$ git branch
```
The command `git branch` will list every branch that you project has, and it will mark the branch that you are currently in with a `*` sign. The main branch (that every project has) is called `master`. 

```
$ git branch [branch-name]
```
Using `git branch` with a name as 3rd parameter will create a new branch. This branch will point to the spot on the project that you are at the moment. For example, If I call `git branch test` with the repository up-to-date on the `master` branch, my new branch (`test`) will point to the last commit of the `master` branch. This means that everything that the branch `master` has, the branch `test` will have too.

```
$ git checkout [branch-name]
```
This command will switch from the branch that you are in to the one specified.

```
$ git checkout -b [branch-name]
```
You can use the `-b` flag to create the new branch and switch to it at the same time.

```
$ git merge [branch]
```
To merge branches, you will checkout to the branch that you want to add the modifications. For example, now that I am done with the `test` branch, I want to merge it with the `master` branch. So I have to run `git checkout master` and then run `git merge test`. This will merge what is in the `test` branch with the `master` branch.
But this command can create a conflict problem. The conflict will happen if we change the same file in different branches. For example, I made changes in the file `main.cpp` in the `test` branch. Then, I went back to the `master branch` and made more changes there, in the same `main.cpp` file. When you try to merge the branches, you will get an error message. To solve this problem you have to open the file that has the conflict and manually merge the different lines of code. The lines between `<<<<<<< HEAD` and `=======` are from the `master` branch, while the lines between `=======` and `>>>>>>> test` are from the `test` branch.


```
$ git branch -d [branch-name]
```
Command to delete a branch.


#####REVIEW HISTORY
Browse and inspect the history of the project.
```
$ git log
$ git log -p
$ git log -p -2
```
With `git log` command, you will have the list of the commits made in that repository in reverse chronological order. If you add the flag `-p`, the output will be a list of commits with the diff introduced in each one. You can also limit the number of commits you want displayed with the flag `-[number]`, which will display the number of commits you want.


```
$ git diff [first-branch]...[second-branch]
```
The `git diff` command is used to see the difference between commits, branches, etc. For example, the `git diff test...master` will show the changes that occurred on the master branch since when the test branch was started off it.


#####SYNCHRONIZE CHANGES
Keep your local repository and your project on GitHub the same.

```
$ git push
```
With `git push`, you will send all the commits you made in your local repository to GitHub.


```
$ git pull
```
  With `git pull`, you will update your local repository with what is in GitHub. For example, you are working on a team on the same project. When somebody changes the code and push it to GitHub, you will take those changes with the `git pull` command.


```
$ git push origin [tag name]
```
When you use the `git push` command, every commit is pushed to GitHub. But to push your tags you have to use the command `git push origin [tag name]` with the tag name. This will update the tags on GitHub. 

```
$ git push origin --tags
```
Using the `--tags` flag, you will push all tags to GitHub.

# signal handling

You should complete this lab using pair programming with a new partner.

### coding instructions

Write a program called `handle_signals` that:

1.  Inside of an infinite loop prints the letter `X` to the stdout.  After you print each character, you must flush the buffer and pause for one second.

2. Whenever the user types a `^C` (interrupt), print the letter `C` to stdout.  DO NOT ABORT THE PROGRAM. 

3. Whenever the user types a `^\` (quit), print the letter `\` to stdout.  DO NOT QUIT THE PROGRAM. 

4. Whenever the user types a `^Z` (stop), print the letter `S` to stdout.  Then stop the program.  You may resume the program using the `fg` command in the shell.

5. When `^Z` is pressed for the third time, print a summary of how many times `^C`, `^\`, and `^Z` were pressed.  Then exit the program.

### references

You should read the man pages for the `signal` and `sigaction` functions.

You may also find this tutorial helpful, but it is not required reading:  http://www.alexonlinux.com/signal-handling-in-linux

### deliverables

When finished, demo your working code for the TA.  
# learning `vim`

In this lab, you will familiarize yourself with the `vim` text editor.  In this class, you must use `vim` for all homework and lab assignments.  At first, you will find that `vim` is very weird.  But with practice, you will find `vim` much more powerful than either the `geany` or `Cloud9` editors you are already familiar with.  

The key to mastering `vim` is practice.  Therefore, you are required to use `vim` for all lab and homeworks assignments in this course.  **Using any editor other than `vim` will result in a 0 on the assignment.**

Open up a terminal and type the command `vimtutor` to get started.  This command walks you through the basics of using the `vim` editor.  Don't just read the file!!!  Make sure to actually do the exercises!!!

Once you have finished that, start playing the game: http://vim-adventures.com.
The first three levels are free (and that's all you're required to do).
You're welcome to pay for the full game if you want, but I'm not requiring you to do so.
And you won't get any extra credit for it.

## vim links

Here's some extra (optional but recommended) reading:

[stackoverflow: what is your most productive shortcut with vim?](http://stackoverflow.com/questions/1218390/what-is-your-most-productive-shortcut-with-vim)

[stackoverflow: simple vim commands you wish you'd known earlier](http://stackoverflow.com/questions/1276403/simple-vim-commands-you-wish-youd-known-earlier)

[vim for people who think things like vim are weird and hard](http://csswizardry.com/2014/06/vim-for-people-who-think-things-like-vim-are-weird-and-hard/)

## deliverables

None
# more command line utilities

The commands will require you to use the `link`, `unlink`, and `rmdir` system commands.

### `rm`

Implement your own version of the `rm` command.  You must be able to support an unlimited number of files passed in as command line parameters.  If any of those files are directories, you must not delete them unless the optional `-r` flag is also present.  Instead, print a warning message.

### `mv`

Implement your own version of the `mv` command.  Given the command:

```
mv file1 file2
```

If `file2` does not exist, then you should rename `file1` to `file1`.  Otherwise, if `file2` is a directory, you should move `file1` into `file2`.  If `file2` is not a directory, you should print an error message.

## a local Linux installation

Install Linux on your personal desktop/laptop computer.
I personally use the [Debian](http://www.debian.org/) and [Slackware](http://slackware.org) distributions, but you're free to choose whatever distribution you like.
The lab machines use [CentOS](http://www.centos.org).

There are two ways you can install Linux.
The first is as a dual boot operating system.
Every Linux distribution's installer will walk you through how to do this.
But be careful!
It's very easy to accidentally erase all your old data!
So make backups first!

The second option is as a virtual machine inside of your windows/mac computer.
This option will earn you a little bit less credit on the assignment, but is easier to set up.

**RECOMENDATION:**
Make this a group activity.
Get together with some of your classmates and spend a Saturday installing Linux on everyone's computers.
It will be a lot more fun this way, and you'll be able to help each other out when you get stuck.

### grading

25 / 25 points for a fully working bootable Linux installation.

20 / 25 points for a virtual machine Linux installation.

If you installed Linux onto a laptop, bring your laptop to class and I will check you off.  You must have wireless internet working for full credit!

If you installed Linux onto a desktop machine, then we will ssh into your desktop from the school account.  You must install the ssh daemon and configure your network routing appropriately.

**IMPORTANT:**
If you already have Linux installed on one of your machines, you do NOT have to reinstall it for this assignment.
You will get full credit.

**IMPORTANT:**
If you do not have a personal computer to install Linux on, see me and I'll work out an alternate assignment.

#### extra credit

+5 points if you install the [xmonad](http://xmonad.org/) tiling window manager and use it as your default

+5 points if you set up your computer as a [tor relay](https://www.torproject.org/docs/tor-doc-relay.html.en)
